[["index.html", "The {squidSim} R Package Vignette The {squidSim} R package", " The {squidSim} R Package Vignette Joel Pick 2022-02-08 The {squidSim} R package The squidSim R package is designed to simplify data simulation from a highly flexible set of models, including: Correlated and interacting predictor variables Non-gaussian data (Poisson and binomial) Crossed and nested hierarchical structures Random intercepts and slopes Univariate and multivariate data Within level-specific residual variance (DHGLMs) Additive genetic effects (animal models) Phylogenetic effects with different models of evolution Temporal and spatial autocorrelation Missing data (MNAR, MAR and MCAR) Temporal sampling The main idea is that anything you can model using a linear mixed effect model framework (assuming underlying multivariate normality) you should be able to simulate using the squid package. Why use squidSim? For people confident with programming in R, simulating data doesn’t provide a huge challenge. However, to those less confident with programming, or the process of data simulation more generally, starting with simulations can seem like a daunting task. The {squidSim} R package is designed to facilitate that transition, and to focus attention on the data structure and parameters needed for simulation, rather than the programming knowledge. {squidSim} also provides a useful tool for experienced programmers. One problematic aspect of collaborative coding (or reviewing someone else’s code) is that many people have very contrasting programming styles. Another motivation for the squid package is that it provides a consistent framework for simulations, which can be interpreted by many people rather than having to decipher someone’s personal code. Using the vignette If you are new to using the {squidSim} package, we recommend that you read Sections 1 and 2 to familiarise yourself with the squid package before moving onto the more advanced topics. The later sections assume an certain level of understanding of how the functions work. The vignette assumes that you have a working knowledge of R. Installation The new squid functions are currently in the development version of the squid package on github: devtools::install_github(&quot;squid-group/squidSim&quot;) library(squidSim) Issues and bugs It would be great if you could report any suggestions, issues or bugs using github issues https://github.com/squid-group/squidSim/issues. It is worth checking to see if anyone else has a similar problem first, and adding comments to their issue, before starting a new one. "],["1-linearmod.html", "1 Simulating population level data", " 1 Simulating population level data Stuff about underlying ethos - Create population and then sample from it Make Hierarchical Structure ↓ Simulate data ↓ Sample Data "],["1.1-simulate_population-function.html", "1.1 simulate_population function", " 1.1 simulate_population function The heart of the squidSim R package is the simulate_population function, which we can use to simulate hierarchical population level data. We provide the function with a set of parameters, a hierarchical data structure (if we are simulating hierarchical data), and various other optional arguments, which are listed below. The simulate_population function simulates predictors at each hierarchical level, using provided mean and vcov parameters, from a multivariate normal distribution. These predictors are then scaled by the beta parameters, and added together to create the response. The arguments that can be provided to the simulate_population function (along with their defaults) are: simulate_population( data_structure, N, parameters, N_response=1, family=&quot;gaussian&quot;, link=&quot;identity&quot;, model, known_predictors, pedigree, pedigree_type, phylogeny, phylogeny_type, cov_str, sample_type, sample_param, N_pop=1 ) Each of these will be covered in more detail in the following sections. Briefly, N and data_structure refer to the size and structure of the data being simulated - data_structure is covered in more detail in Section 2. parameters is a list of parameters to be used in the simulation and is described in detail in the following parts of this section. N_response refers the number of response variable to be simulated and is covered in detail in the section on multivariate models (3). family and link refer to simulating non Gaussian response variables and are covered in Section 1.7. model allows for the specification of more complex models and is covered in Section 1.8. pedigree and pedigree_type relate to simulating genetic effects and are covered in Section 4, phylogeny and phylogeny_type, relate to simulating phylogenetic effects and are covered in Section 5and cov_str relates to simulating a general covariance structure and is covered in multiple sections, including 4, 5, 6.3 and 6.4. sample_type and sample_param relate to different sampling methods and are covered in Section 7 N_pop relates to the number of populations, or datasets, that you want to simulate for each parameter set. This is covered in Section 1.9 "],["1.2-simple-linear-model.html", "1.2 Simple Linear Model", " 1.2 Simple Linear Model We will start simulating data without any hierarchical structure, i.e. everything varies at the level of the observation. Let’s imagine a situation where we have some predictor variables (\\(x_1\\), \\(x_2\\), \\(x_3\\)) that vary at the level of the observation, which affect a response variable (\\(y\\)), each with a certain magnitude and direction of their effect (or the slope; \\(\\beta_1\\) etc), as well as some unexplained, residual variation (\\(\\epsilon\\)). These are added together to give create the response variable. We can write this out in the form of a linear model: \\[ y = \\beta_0 + \\beta_1 * x_1 + \\beta_2 * x_2 + \\beta_3 * x_3 + \\epsilon \\] We can also write this in matrix notation \\[ y = \\beta_0 + \\boldsymbol X \\beta + \\epsilon \\] where \\(X\\) is a matrix of predictors and \\(\\beta\\) is a (column) vector of slopes. If we want to simulate from this model, we can assume that these predictor variables are multivariate normally distributed, with given means (\\(\\mu\\)) and a covariance structure (\\(\\Sigma_x\\)), and the residuals are normally distributed with a given variance (\\(\\sigma^2_\\epsilon\\)) \\[ \\boldsymbol X \\sim MVN(\\mu_x,\\Sigma_x) \\] \\[ \\epsilon \\sim N(0,\\sigma^2_\\epsilon) \\] The key to simulating data using the squidSim package is correctly specifying the parameters (from the equations above that would be \\(\\beta\\), \\(\\mu\\), \\(\\Sigma_x\\), \\(\\sigma^2_\\epsilon\\)). These parameters are given to the simulate_population function as a nested list. Within the main parameter list, there are named lists corresponding to different hierarchical levels, containing the parameters for the predictors at that level - here we are just focussing on the observation level (see Section 2 for examples with hierarchical structure). Parameters for the residual must be specified, all other levels are optional. Many of the components in the parameter list don’t need to be specified and default values will be created. Let’s simulate from the above model. To simulate the predictors varying at the level of the observation, we can use the observation and residual slots in the parameter list, to specify the parameters for the observation level predictors and the residuals, respectively. For both observation and residual we create a list containing the respective parameters. Let’s start with the observation list. We can then specify the names of these variables as a vector (these can be anything - I like giving things actual names, but could also be x_1, x_2 and x_3) and, in the simplest case, the \\(\\beta\\) values as a vector. observation = list( names = c(&quot;temperature&quot;,&quot;rainfall&quot;, &quot;wind&quot;), beta = c(0.5,-0.3, 0.4) ) By default, these predictors are simulated as i.i.d. unit normals (mean=0, var=1, cov=0). Note that the order of the names and betas has to match. We can then specify the residual variance, here as 1 residual = list( vcov = 1 ) As we haven’t given any data structure (see Section 2), we also have to specify the sample size as an argument to the simulate_population function (N=2000). We put this together: squid_data &lt;- simulate_population( parameters = list( observation = list( names = c(&quot;temperature&quot;,&quot;rainfall&quot;, &quot;wind&quot;), beta = c(0.5,-0.3, 0.4) ), residual = list( vcov = 1 ) ), N=2000 ) This generates a squid object, which when run returns a friendly message squid_data ## Data simulated using squid ## ## /\\ ## / \\ ## / /\\ \\ ## \\/ \\/ ## / \\ ## | | ## | | ## 0 | | 0 ## / \\____/ \\ ## { __/( )\\__ } ## \\___/__\\_\\/_/__\\___/ ## / / / / \\ \\ \\ \\ ## / / / { } \\ \\ \\ ## { { / \\ / \\ } } ## } \\ 0 0 / { ## 0_/ { \\_0 0_/ } \\_0 ## \\ / ## } { ## / \\ ## 0 0 At this point we want to be able to access the simulated data. There are then some further functions which we can use to access the data and simulation parameters. We can extract the simulated data using get_population_data() The generated response is returned as y, along with simulated predictors and the data structure (not relevant here). data &lt;- get_population_data(squid_data) head(data) ## y temperature rainfall wind residual_effect squid_pop ## 1: 2.2108871 0.6448170 -0.8044162 1.305555391 1.1249316 1 ## 2: 1.2487662 0.1205662 0.3028756 0.008271866 1.2760370 1 ## 3: 0.6322075 1.0742952 -0.0452464 -1.135084553 0.5355199 1 ## 4: -1.1318554 -1.8321021 0.8883157 0.540524071 -0.1655192 1 ## 5: -1.8463471 -0.3208242 -0.3907593 -0.684058758 -1.5295393 1 ## 6: 0.8742132 -0.9668005 0.8530260 0.593361504 1.3761766 1 We can plot what we have simulated: library(scales) par(mfrow=c(1,3)) plot(y ~ temperature + rainfall + wind, data, pch=19, cex=0.5, col=alpha(1,0.5)) and run a linear model to check that we get back what we have simulated: coef(lm(y ~ temperature + rainfall,data)) ## (Intercept) temperature rainfall ## -0.02778212 0.51120855 -0.29331514 1.2.1 Adding more information about the predictors We can also specify the predictors as having different means and variances, and specify a global intercept (\\(\\beta_0\\)), by specifying a mean for the residual part (mean=10 in the example below). In the observation list, mean and vcov specify the means and covariance matrix of the predictors. If the predictors were uncorrelated, we can just specify the variances as a vector (the diagonal elements of the covariance matrix), and the function assumes the covariances are 0 (see section 1.3 for correlated predictors). So below we have three predictors, temperature, rainfall and wind, with means 10, 1 and 20 respectively, variances 1, 0.1 and 2, respectively, and betas 0.5,-3 and 0.4, a residual variance 0.8 and a global intercept of 10. squid_data &lt;- simulate_population( parameters=list( observation=list( names=c(&quot;temperature&quot;,&quot;rainfall&quot;, &quot;wind&quot;), mean = c(10,1,20), vcov =c(1,0.1,2), beta =c(0.5,-3,0.4) ), residual=list( mean=10, vcov=0.8 ) ), N=2000 ) data &lt;- get_population_data(squid_data) library(scales) par(mfrow=c(1,3)) plot(y ~ temperature + rainfall + wind, data, pch=19, cex=0.5, col=alpha(1,0.5)) coef(lm(y ~ temperature + rainfall + wind, data)) ## (Intercept) temperature rainfall wind ## 9.6570570 0.5188357 -3.0521469 0.4119509 "],["1.3-corpred.html", "1.3 Correlated predictors", " 1.3 Correlated predictors We can simulate correlations between these predictors, as vcov specifies the variance/covariance matrix of the predictors. squid_data &lt;- simulate_population( parameters=list( observation=list( names=c(&quot;temperature&quot;,&quot;rainfall&quot;, &quot;wind&quot;), mean = c(10,1 ,20), vcov =matrix(c( 1, 0, 1, 0,0.1,0, 1, 0, 2 ), nrow=3 ,ncol=3), beta =c(0.5,-3,0.4) ), residual=list( mean=10, vcov=1 ) ), N=2000 ) data &lt;- get_population_data(squid_data) library(scales) par(mfrow=c(1,3)) plot(y ~ temperature + rainfall + wind, data, pch=19, cex=0.5, col=alpha(1,0.5)) coef(lm(y ~ temperature + rainfall + wind, data)) ## (Intercept) temperature rainfall wind ## 9.9924873 0.5607588 -2.9806171 0.3701368 div.blue { background-color:#fcba03; border-radius: 5px; padding: 20px;} Matrices in R To code a matrix in R we use the matrix function (see ?matrix). This takes a vector of values, and arranges then in a matrix, with dimensions specified with nrow and ncol. By default it fills the matrix by column, which can be changed by specifying byrow=TRUE. For big matrices this can be petty annoying. TheTri2M() function from the package MCMCglmm allows you to just give the lower or upper half of the matrix, and it will fill the rest out for you. For example, we can make a correlation matrix using: Tri2M(c(1,0.5,1,0.3,0.2,1), lower.tri = FALSE, diag=TRUE) ## [,1] [,2] [,3] ## [1,] 1.0 0.5 0.3 ## [2,] 0.5 1.0 0.2 ## [3,] 0.3 0.2 1.0 Instead of specifying a variance-covariance matrix (vcov), we can also specify a variance-correlation matrix (variance on the diagonals and correlations on the off-diagonals), using vcorr squid_data &lt;- simulate_population( parameters=list( observation=list( names=c(&quot;temperature&quot;,&quot;rainfall&quot;, &quot;wind&quot;), mean = c(10,1,20), vcorr =matrix(c( 1, -0.2, 0.5, -0.2, 0.1, 0.3, 0.5, 0.3, 2 ), nrow=3 ,ncol=3), beta =c(0.5,-3,0.4) ), residual=list( mean=10, vcov=1 ) ), N=2000 ) data &lt;- get_population_data(squid_data) cor(data[,c(&quot;temperature&quot;,&quot;rainfall&quot;, &quot;wind&quot;)]) ## temperature rainfall wind ## temperature 1.000000 -0.189244 0.509955 ## rainfall -0.189244 1.000000 0.318288 ## wind 0.509955 0.318288 1.000000 Through simulating correlated predictors, we can also simulate more interesting phenomena. For example, we may want to simulate the effect of a correlated missing predictor. Here, rain and wind, but not temperature, affect adult body mass, but only temperature and rainfall are measured: squid_data &lt;- simulate_population( parameters=list( observation=list( names=c(&quot;temperature&quot;,&quot;rainfall&quot;, &quot;wind&quot;), mean = c(10,1 ,20), vcov =matrix(c( 1, 0, 1, 0,0.1,0, 1, 0, 2 ), nrow=3 ,ncol=3), beta =c(0.5,-3,0.4) ), residual=list( mean=10, vcov=1 ) ), N=2000 ) data &lt;- get_population_data(squid_data) library(scales) par(mfrow=c(1,3)) plot(y ~ temperature + rainfall + wind, data, pch=19, cex=0.5, col=alpha(1,0.5)) coef(lm(y ~ temperature + rainfall, data)) ## (Intercept) temperature rainfall ## 14.2183793 0.8885276 -3.0926280 coef(lm(y ~ temperature + rainfall + wind, data)) ## (Intercept) temperature rainfall wind ## 10.1426587 0.5033866 -3.1104768 0.3979375 We can also use this to induce measurement error in a predictor - we can simulate the true variable with a certain affect on the response, and another correlated variable - the measured variable - with no direct effect on the response. The correlation between these two variables represents the measurement error (the repeatability of the variable is the correlation squared). "],["1.4-interactions-and-non-linear-effects.html", "1.4 Interactions and non-linear effects", " 1.4 Interactions and non-linear effects 1.4.1 Interactions We can specify the interaction between two predictors by adding an ‘iterations’ list to the parameters list. Interactions can then be specified between two named variables using “:”. Interactions can be between predictors at the same or different hierarchical level. squid_data &lt;- simulate_population( parameters=list( observation=list( names=c(&quot;temperature&quot;,&quot;rainfall&quot;), beta = c(0.5,0.3) ), residual=list( vcov=0.3 ), interactions=list( names=c(&quot;temperature:rainfall&quot;), beta = c(-0.1) ) ), N=2000 ) data &lt;- get_population_data(squid_data) head(data) ## y temperature rainfall residual_effect temperature:rainfall ## 1: 1.1612011 0.30688959 -0.2101704 1.0643575 -0.06449910 ## 2: -0.9901968 -0.21776477 -0.2405348 -0.8039160 0.05237999 ## 3: -0.4748649 0.58583864 -0.4947716 -0.6483383 -0.28985633 ## 4: -0.3031447 0.72582754 -0.7901652 -0.4863613 -0.57352364 ## 5: 0.2177736 0.43439190 0.5626712 -0.1437817 0.24441982 ## 6: 0.8116988 -0.07236763 1.4520166 0.4017697 -0.10507900 ## squid_pop ## 1: 1 ## 2: 1 ## 3: 1 ## 4: 1 ## 5: 1 ## 6: 1 coef(lm(y ~ temperature * rainfall, data)) ## (Intercept) temperature rainfall ## -0.005367357 0.488210411 0.318141034 ## temperature:rainfall ## -0.088127822 1.4.2 Non-linear effects Polynomial (quadratic, cubic, etc) functions are essentially interactions with the same predictor. They can therefore be specified in the same way: squid_data &lt;- simulate_population( parameters=list( observation=list( names=c(&quot;temperature&quot;), beta = c(0.5) ), interactions=list( names=c(&quot;temperature:temperature&quot;), beta = c(-0.3) ), residual=list( vcov=0.3 ) ), N=2000 ) data &lt;- get_population_data(squid_data) plot(y ~ temperature, data, pch=19, cex=0.5, col=alpha(1,0.5)) coef(lm(y ~ temperature + I(temperature^2), data)) ## (Intercept) temperature I(temperature^2) ## -2.955916e-05 5.118423e-01 -2.957870e-01 "],["1.5-transformations.html", "1.5 Transformations", " 1.5 Transformations We may want to simulate predictors that are not normally distributed. Although the underlying simulation procedure assumes multivariate normality, the predictors can be transformed, before they are scaled by the beta values. To do this we can use provide the transformation function to the functions option of a given parameter list, as a character vector. The given funtion needs to b a known function in R. The below code will exponentiate rainfall (using the exp function), before it is scaled by its beta (here 2). squid_data &lt;- simulate_population( parameters=list( observation=list( names=c(&quot;temperature&quot;,&quot;rainfall&quot;), functions=c(NA,&quot;exp&quot;), beta = c(0.5,0.3) ), residual=list( vcov=0.3 ) ), N=2000 ) data &lt;- get_population_data(squid_data) head(data) ## y temperature rainfall residual_effect squid_pop ## 1: 0.25303642 0.3194564 2.8914783 -0.7741352 1 ## 2: 0.07182133 -1.2119216 1.4274460 0.2495483 1 ## 3: 0.28938682 0.2917695 0.9670624 -0.1466166 1 ## 4: -0.12618403 -0.1939646 0.4571713 -0.1663531 1 ## 5: -0.24803757 -0.3708652 1.7820173 -0.5972102 1 ## 6: -0.80662137 -1.3157503 0.1939773 -0.2069394 1 hist(data$rainfall, breaks=100) If a covariance between variables is specified, this covariance is on the untransformed (Gaussian) scale (as the variables are simulated as multivariate normal), NOT on the transformed scale, so care should be taken with this. For example: squid_data &lt;- simulate_population( parameters=list( observation=list( names=c(&quot;temperature&quot;,&quot;rainfall&quot;), vcov=matrix(c(1,0.7,0.7,1), nrow=2), functions=c(NA,&quot;exp&quot;), beta = c(0.5,0.3) ), residual=list( vcov=0.3 ) ), N=2000 ) data &lt;- get_population_data(squid_data) cov(data$temperature,data$rainfall) ## [1] 1.096314 cov(data$temperature,log(data$rainfall)) ## [1] 0.6714665 The simulate covariance can be recovered on the backtransformed predictor. "],["1.6-known-predictors.html", "1.6 Known Predictors", " 1.6 Known Predictors We might have the situation where we don’t want to simulate a predictor, rather use existing data to simulate a response variable from. This has the advantage that any quirks of existing data (like a strange distribution) can be maintained. These predoctors can be fed into the simulate_population function, using the known_predictors argument. This argument takes a list, with one item, called predictors, a matrix or dataframe of predictors and one item called beta, with the beta values for the respective predictors. Importantly, the predictors have to be the same length as number of observations in the simulated data. We can demonstrate this using the blue tit data set that comes with the MCMCglmm package. library(MCMCglmm) data(BTdata) head(BTdata) ## tarsus back animal dam fosternest hatchdate sex ## 1 -1.89229718 1.1464212 R187142 R187557 F2102 -0.6874021 Fem ## 2 1.13610981 -0.7596521 R187154 R187559 F1902 -0.6874021 Male ## 3 0.98468946 0.1449373 R187341 R187568 A602 -0.4279814 Male ## 4 0.37900806 0.2555847 R046169 R187518 A1302 -1.4656641 Male ## 5 -0.07525299 -0.3006992 R046161 R187528 A2602 -1.4656641 Fem ## 6 -1.13519543 1.5577219 R187409 R187945 C2302 0.3502805 Fem We can see that in this dataset there are several continuous predictors. Here we will use “hatchdate” and “tarsus”. squid_data &lt;- simulate_population( parameters=list( observation=list( names=c(&quot;temperature&quot;,&quot;rainfall&quot;), beta = c(0.5,0.3) ), residual=list( vcov=0.3 ) ), known_predictors = list( predictors = BTdata[,c(&quot;hatchdate&quot;,&quot;tarsus&quot;)], beta = c(1,2)), N = nrow(BTdata) ) data &lt;- get_population_data(squid_data) head(data) ## y temperature rainfall residual_effect hatchdate tarsus ## 1: -3.8947641 0.5204820 0.36696780 0.2069009 -0.6874021 -1.89229718 ## 2: 2.2741284 1.7799214 0.09771241 -0.2299636 -0.6874021 1.13610981 ## 3: 1.8459652 2.6362310 -0.26891380 -0.9328737 -0.4279814 0.98468946 ## 4: -0.4604693 1.2043972 -1.75195903 0.1705678 -1.4656641 0.37900806 ## 5: -1.6932511 -0.6229676 0.14487246 0.1909410 -1.4656641 -0.07525299 ## 6: -2.8273304 -0.3246487 0.03954678 -0.7567598 0.3502805 -1.13519543 ## squid_pop ## 1: 1 ## 2: 1 ## 3: 1 ## 4: 1 ## 5: 1 ## 6: 1 plot(y~hatchdate,data) "],["1.7-nonGaussian.html", "1.7 Non-Gaussian phenotypes", " 1.7 Non-Gaussian phenotypes To simulate non-Gaussian data, we can specify a link function and a family as arguments to the simulate_population function. Underneath the predictors are being simulated as multivariate normal, and then the resulting phenotype is transformed. \\[ y \\sim Poisson(\\hat{y}) \\] \\[ \\hat{y} = exp( \\beta_0 + \\boldsymbol X \\beta + \\epsilon ) \\] \\[ \\boldsymbol X \\sim MVN(\\mu_x,\\Sigma_x) \\] \\[ \\epsilon \\sim N(0,\\sigma^2_\\epsilon) \\] squid_data &lt;- simulate_population( parameters=list( observation=list( names=c(&quot;temperature&quot;,&quot;rainfall&quot;), beta = c(0.2,0.1) ), residual=list( mean=1.75, vcov=0.2 ) ), N=2000, family=&quot;poisson&quot;, link=&quot;log&quot; ) data &lt;- get_population_data(squid_data) head(data) ## y temperature rainfall residual_effect squid_pop ## 1: 4 -1.61506824 -0.2217387 1.282343 1 ## 2: 2 -0.75411538 0.3102960 1.370828 1 ## 3: 2 -1.06063343 0.4100676 1.155145 1 ## 4: 7 -2.18635065 -0.1901900 2.352954 1 ## 5: 9 -0.03147872 -0.4204572 1.831198 1 ## 6: 9 -0.40296500 0.6719130 1.892725 1 plot(table(data$y), ylab=&quot;Frequency&quot;, xlab=&quot;z&quot;) glm(y ~ temperature + rainfall, data, family=&quot;poisson&quot;) ## ## Call: glm(formula = y ~ temperature + rainfall, family = &quot;poisson&quot;, ## data = data) ## ## Coefficients: ## (Intercept) temperature rainfall ## 1.8156 0.1798 0.1106 ## ## Degrees of Freedom: 1999 Total (i.e. Null); 1997 Residual ## Null Deviance: 5213 ## Residual Deviance: 4657 AIC: 11590 "],["1.8-modeleq.html", "1.8 Model equations", " 1.8 Model equations In all the examples so far, the predictors are simulated, scaled by their respective beta value, and then added together. We may want to prevent some of this behaviour or add in additional parameters, interactions or general complexity. In isolation, the functionality outlined here it might seem a bit redundant, but it becomes useful for more complex models. To introduce this increased complexity, we can specify a model formula. This explicitly tells the simulate_population function how to put the simulated predictors together to form the response variable. We can first demonstrate this with a simple linear model. squid_data &lt;- simulate_population( parameters=list( observation= list( names = c(&quot;temperature&quot;, &quot;rainfall&quot;), beta =c(0.5,0.3) ), residual = list( names=&quot;residual&quot;, vcov=1 ) ), N=2000, model = &quot;y = temperature + rainfall + residual&quot; ) data &lt;- get_population_data(squid_data) coef(lm(y ~ temperature + rainfall, data)) ## (Intercept) temperature rainfall ## -0.03117499 0.51738483 0.30049927 In the formula, we write out how the variables are added up. Everything that you want exported needs to be defined and named (e.g. y=...). By default they are all scaled by their beta values before this happens. Sometimes it is useful to prevent this (i.e. multiply two traits together without them being scaled by their respective beta) and we can do this by using I(). squid_data &lt;- simulate_population( parameters=list( observation= list( names = c(&quot;temperature&quot;, &quot;rainfall&quot;), beta =c(0.5,0.3) ), residual = list( names=&quot;residual&quot;, vcov=1 ) ), N=2000, model = &quot;y = temperature + I(rainfall) + residual&quot; ) data &lt;- get_population_data(squid_data) coef(lm(y ~ temperature + rainfall, data)) ## (Intercept) temperature rainfall ## -0.01299137 0.50414545 1.04104296 We can also add extra parameters to the parameter list, which we can call from within the function. In combination with I() we can then customise the model formula a bit squid_data &lt;- simulate_population( parameters=list( observation= list( names = c(&quot;temperature&quot;, &quot;rainfall&quot;), beta =c(0.5,0.3), extra_beta = 0.1 ), residual = list( names=&quot;residual&quot;, vcov=1 ) ), N=2000, model = &quot;y = temperature + extra_beta*I(rainfall) + residual&quot; ) data &lt;- get_population_data(squid_data) coef(lm(y ~ temperature + rainfall, data)) ## (Intercept) temperature rainfall ## 0.0363315 0.4914638 0.1121997 Finally, we can use [] to index the levels of the random effects within the formula… "],["1.9-npop.html", "1.9 Simulating multiple populations", " 1.9 Simulating multiple populations We can use the simulate_population() function to generate multiple datasets (populations) form the same set of parameters (world). To do this we can specify the N_pop argument in simulate_population(). This defaults to 1. squid_data &lt;- simulate_population( parameters = list( individual = list( vcov = 0.5 ), residual = list( vcov = 0.5 ) ), data_structure = make_structure(structure = &quot;sex(2)/individual(1000)&quot;, N=2000), N_pop=5 ) By default get_population_data returns a data.table, where the squid_pop column indicates the population data &lt;- get_population_data(squid_data) head(data) ## y individual_effect residual_effect sex individual squid_pop ## 1: 1.5748140 0.41303272 1.1617813 1 1 1 ## 2: 0.4118978 -0.16564095 0.5775388 1 2 1 ## 3: 1.3249120 0.63513505 0.6897770 1 3 1 ## 4: -0.7713207 0.07401247 -0.8453332 1 4 1 ## 5: 0.2621901 0.99124253 -0.7290524 1 5 1 ## 6: 1.2326740 0.59190351 0.6407705 1 6 1 It can also be output as a list, which might be more useful for processing many iterations of a simulation. data &lt;- get_population_data(squid_data, list=TRUE) "],["1.10-parameter-list-summary.html", "1.10 Parameter list summary", " 1.10 Parameter list summary names group mean vcov vcorr beta fixed covariate functions "],["2-hierarchical.html", "2 Hierarchical structure", " 2 Hierarchical structure There are two parts to simulating hierarchical data. First you need to have a hierarchical data structure and second you need parameters at each of the different hierarchical levels. The data structure is essentially a data.frame (or matrix), with all the grouping factors and their levels, as we would see in a typical dataset. In this Section, we will first demonstrate how to make a hierarchical structure using the make_structure function. simulate_population also allows pre-existing data structures to be incorporated. The remaining part of the section detail how to simulate hierarchical data once you have a hierarchical data structure. "],["2.1-makestr.html", "2.1 Making a hierarchical structure", " 2.1 Making a hierarchical structure We can use the make_structure function to create nested and crossed hierarchical data structures. The make_structure function only produces balanced data structures, but these can be made unbalanced using by sampling, which is outlined in Section 7 2.1.1 Single Factor Simplest structure - one grouping factor with multiple observations. Here we create a structure with 2 repeated observations of 5 individuals (small number are used here simply for illustration purposes). The structure contains the name of the grouping factors and their sample sizes, and repeat_obs is the number of repeated observations. make_structure(structure=&quot;individual(5)&quot;, repeat_obs=2) ## individual ## 1 1 ## 2 1 ## 3 2 ## 4 2 ## 5 3 ## 6 3 ## 7 4 ## 8 4 ## 9 5 ## 10 5 2.1.2 Nested factors If we want to have nested factors, so different hierarchical groups, where levels of one group only exist in one higher group then we can use the / symbol in the structure argument. For example, here we have 2 sexes, each with 5 individuals, with 2 repeated measurements each. make_structure(structure=&quot;sex(2)/individual(5)&quot;, repeat_obs=2) ## sex individual ## 1 1 1 ## 2 1 1 ## 3 1 2 ## 4 1 2 ## 5 1 3 ## 6 1 3 ## 7 1 4 ## 8 1 4 ## 9 1 5 ## 10 1 5 ## 11 2 6 ## 12 2 6 ## 13 2 7 ## 14 2 7 ## 15 2 8 ## 16 2 8 ## 17 2 9 ## 18 2 9 ## 19 2 10 ## 20 2 10 Note that in the nesting, the sample size for the lower group now represents the number within each level of the higher, rather than the total sample size, so overall there is 10 individuals. We can nest as much as we want: make_structure(structure=&quot;species(2)/population(2)/individual(2)&quot;, repeat_obs=2) ## species population individual ## 1 1 1 1 ## 2 1 1 1 ## 3 1 1 2 ## 4 1 1 2 ## 5 1 2 3 ## 6 1 2 3 ## 7 1 2 4 ## 8 1 2 4 ## 9 2 3 5 ## 10 2 3 5 ## 11 2 3 6 ## 12 2 3 6 ## 13 2 4 7 ## 14 2 4 7 ## 15 2 4 8 ## 16 2 4 8 2.1.3 Crossed factors We can create completely crossed factors - every combination of levels exists - using the + symbol in the structure argument make_structure(structure=&quot;treatment(2) + individual(5)&quot;, repeat_obs=1) ## treatment individual ## 1 1 1 ## 2 1 2 ## 3 1 3 ## 4 1 4 ## 5 1 5 ## 6 2 1 ## 7 2 2 ## 8 2 3 ## 9 2 4 ## 10 2 5 We can combine crossed and nested structures: make_structure(structure=&quot;treatment(2) + sex(2)/individual(5)&quot;, repeat_obs=1) ## treatment sex individual ## 1 1 1 1 ## 2 1 1 2 ## 3 1 1 3 ## 4 1 1 4 ## 5 1 1 5 ## 6 1 2 6 ## 7 1 2 7 ## 8 1 2 8 ## 9 1 2 9 ## 10 1 2 10 ## 11 2 1 1 ## 12 2 1 2 ## 13 2 1 3 ## 14 2 1 4 ## 15 2 1 5 ## 16 2 2 6 ## 17 2 2 7 ## 18 2 2 8 ## 19 2 2 9 ## 20 2 2 10 We can also output the crossed and nested using : make_structure(structure=&quot;treatment(2) + individual(5) + treatment:individual&quot;, repeat_obs=1) ## treatment individual treatment:individual ## 1 1 1 1 ## 2 1 2 2 ## 3 1 3 3 ## 4 1 4 4 ## 5 1 5 5 ## 6 2 1 6 ## 7 2 2 7 ## 8 2 3 8 ## 9 2 4 9 ## 10 2 5 10 2.1.4 Temporal structure make_structure(structure=&quot;year(2)/month(12)/day(30)&quot;, repeat_obs=1) ## year month day ## 1 1 1 1 ## 2 1 1 2 ## 3 1 1 3 ## 4 1 1 4 ## 5 1 1 5 ## 6 1 1 6 ## 7 1 1 7 ## 8 1 1 8 ## 9 1 1 9 ## 10 1 1 10 ## 11 1 1 11 ## 12 1 1 12 ## 13 1 1 13 ## 14 1 1 14 ## 15 1 1 15 ## 16 1 1 16 ## 17 1 1 17 ## 18 1 1 18 ## 19 1 1 19 ## 20 1 1 20 ## 21 1 1 21 ## 22 1 1 22 ## 23 1 1 23 ## 24 1 1 24 ## 25 1 1 25 ## 26 1 1 26 ## 27 1 1 27 ## 28 1 1 28 ## 29 1 1 29 ## 30 1 1 30 ## 31 1 2 31 ## 32 1 2 32 ## 33 1 2 33 ## 34 1 2 34 ## 35 1 2 35 ## 36 1 2 36 ## 37 1 2 37 ## 38 1 2 38 ## 39 1 2 39 ## 40 1 2 40 ## 41 1 2 41 ## 42 1 2 42 ## 43 1 2 43 ## 44 1 2 44 ## 45 1 2 45 ## 46 1 2 46 ## 47 1 2 47 ## 48 1 2 48 ## 49 1 2 49 ## 50 1 2 50 ## 51 1 2 51 ## 52 1 2 52 ## 53 1 2 53 ## 54 1 2 54 ## 55 1 2 55 ## 56 1 2 56 ## 57 1 2 57 ## 58 1 2 58 ## 59 1 2 59 ## 60 1 2 60 ## 61 1 3 61 ## 62 1 3 62 ## 63 1 3 63 ## 64 1 3 64 ## 65 1 3 65 ## 66 1 3 66 ## 67 1 3 67 ## 68 1 3 68 ## 69 1 3 69 ## 70 1 3 70 ## 71 1 3 71 ## 72 1 3 72 ## 73 1 3 73 ## 74 1 3 74 ## 75 1 3 75 ## 76 1 3 76 ## 77 1 3 77 ## 78 1 3 78 ## 79 1 3 79 ## 80 1 3 80 ## 81 1 3 81 ## 82 1 3 82 ## 83 1 3 83 ## 84 1 3 84 ## 85 1 3 85 ## 86 1 3 86 ## 87 1 3 87 ## 88 1 3 88 ## 89 1 3 89 ## 90 1 3 90 ## 91 1 4 91 ## 92 1 4 92 ## 93 1 4 93 ## 94 1 4 94 ## 95 1 4 95 ## 96 1 4 96 ## 97 1 4 97 ## 98 1 4 98 ## 99 1 4 99 ## 100 1 4 100 ## 101 1 4 101 ## 102 1 4 102 ## 103 1 4 103 ## 104 1 4 104 ## 105 1 4 105 ## 106 1 4 106 ## 107 1 4 107 ## 108 1 4 108 ## 109 1 4 109 ## 110 1 4 110 ## 111 1 4 111 ## 112 1 4 112 ## 113 1 4 113 ## 114 1 4 114 ## 115 1 4 115 ## 116 1 4 116 ## 117 1 4 117 ## 118 1 4 118 ## 119 1 4 119 ## 120 1 4 120 ## 121 1 5 121 ## 122 1 5 122 ## 123 1 5 123 ## 124 1 5 124 ## 125 1 5 125 ## 126 1 5 126 ## 127 1 5 127 ## 128 1 5 128 ## 129 1 5 129 ## 130 1 5 130 ## 131 1 5 131 ## 132 1 5 132 ## 133 1 5 133 ## 134 1 5 134 ## 135 1 5 135 ## 136 1 5 136 ## 137 1 5 137 ## 138 1 5 138 ## 139 1 5 139 ## 140 1 5 140 ## 141 1 5 141 ## 142 1 5 142 ## 143 1 5 143 ## 144 1 5 144 ## 145 1 5 145 ## 146 1 5 146 ## 147 1 5 147 ## 148 1 5 148 ## 149 1 5 149 ## 150 1 5 150 ## 151 1 6 151 ## 152 1 6 152 ## 153 1 6 153 ## 154 1 6 154 ## 155 1 6 155 ## 156 1 6 156 ## 157 1 6 157 ## 158 1 6 158 ## 159 1 6 159 ## 160 1 6 160 ## 161 1 6 161 ## 162 1 6 162 ## 163 1 6 163 ## 164 1 6 164 ## 165 1 6 165 ## 166 1 6 166 ## 167 1 6 167 ## 168 1 6 168 ## 169 1 6 169 ## 170 1 6 170 ## 171 1 6 171 ## 172 1 6 172 ## 173 1 6 173 ## 174 1 6 174 ## 175 1 6 175 ## 176 1 6 176 ## 177 1 6 177 ## 178 1 6 178 ## 179 1 6 179 ## 180 1 6 180 ## 181 1 7 181 ## 182 1 7 182 ## 183 1 7 183 ## 184 1 7 184 ## 185 1 7 185 ## 186 1 7 186 ## 187 1 7 187 ## 188 1 7 188 ## 189 1 7 189 ## 190 1 7 190 ## 191 1 7 191 ## 192 1 7 192 ## 193 1 7 193 ## 194 1 7 194 ## 195 1 7 195 ## 196 1 7 196 ## 197 1 7 197 ## 198 1 7 198 ## 199 1 7 199 ## 200 1 7 200 ## 201 1 7 201 ## 202 1 7 202 ## 203 1 7 203 ## 204 1 7 204 ## 205 1 7 205 ## 206 1 7 206 ## 207 1 7 207 ## 208 1 7 208 ## 209 1 7 209 ## 210 1 7 210 ## 211 1 8 211 ## 212 1 8 212 ## 213 1 8 213 ## 214 1 8 214 ## 215 1 8 215 ## 216 1 8 216 ## 217 1 8 217 ## 218 1 8 218 ## 219 1 8 219 ## 220 1 8 220 ## 221 1 8 221 ## 222 1 8 222 ## 223 1 8 223 ## 224 1 8 224 ## 225 1 8 225 ## 226 1 8 226 ## 227 1 8 227 ## 228 1 8 228 ## 229 1 8 229 ## 230 1 8 230 ## 231 1 8 231 ## 232 1 8 232 ## 233 1 8 233 ## 234 1 8 234 ## 235 1 8 235 ## 236 1 8 236 ## 237 1 8 237 ## 238 1 8 238 ## 239 1 8 239 ## 240 1 8 240 ## 241 1 9 241 ## 242 1 9 242 ## 243 1 9 243 ## 244 1 9 244 ## 245 1 9 245 ## 246 1 9 246 ## 247 1 9 247 ## 248 1 9 248 ## 249 1 9 249 ## 250 1 9 250 ## 251 1 9 251 ## 252 1 9 252 ## 253 1 9 253 ## 254 1 9 254 ## 255 1 9 255 ## 256 1 9 256 ## 257 1 9 257 ## 258 1 9 258 ## 259 1 9 259 ## 260 1 9 260 ## 261 1 9 261 ## 262 1 9 262 ## 263 1 9 263 ## 264 1 9 264 ## 265 1 9 265 ## 266 1 9 266 ## 267 1 9 267 ## 268 1 9 268 ## 269 1 9 269 ## 270 1 9 270 ## 271 1 10 271 ## 272 1 10 272 ## 273 1 10 273 ## 274 1 10 274 ## 275 1 10 275 ## 276 1 10 276 ## 277 1 10 277 ## 278 1 10 278 ## 279 1 10 279 ## 280 1 10 280 ## 281 1 10 281 ## 282 1 10 282 ## 283 1 10 283 ## 284 1 10 284 ## 285 1 10 285 ## 286 1 10 286 ## 287 1 10 287 ## 288 1 10 288 ## 289 1 10 289 ## 290 1 10 290 ## 291 1 10 291 ## 292 1 10 292 ## 293 1 10 293 ## 294 1 10 294 ## 295 1 10 295 ## 296 1 10 296 ## 297 1 10 297 ## 298 1 10 298 ## 299 1 10 299 ## 300 1 10 300 ## 301 1 11 301 ## 302 1 11 302 ## 303 1 11 303 ## 304 1 11 304 ## 305 1 11 305 ## 306 1 11 306 ## 307 1 11 307 ## 308 1 11 308 ## 309 1 11 309 ## 310 1 11 310 ## 311 1 11 311 ## 312 1 11 312 ## 313 1 11 313 ## 314 1 11 314 ## 315 1 11 315 ## 316 1 11 316 ## 317 1 11 317 ## 318 1 11 318 ## 319 1 11 319 ## 320 1 11 320 ## 321 1 11 321 ## 322 1 11 322 ## 323 1 11 323 ## 324 1 11 324 ## 325 1 11 325 ## 326 1 11 326 ## 327 1 11 327 ## 328 1 11 328 ## 329 1 11 329 ## 330 1 11 330 ## 331 1 12 331 ## 332 1 12 332 ## 333 1 12 333 ## 334 1 12 334 ## 335 1 12 335 ## 336 1 12 336 ## 337 1 12 337 ## 338 1 12 338 ## 339 1 12 339 ## 340 1 12 340 ## 341 1 12 341 ## 342 1 12 342 ## 343 1 12 343 ## 344 1 12 344 ## 345 1 12 345 ## 346 1 12 346 ## 347 1 12 347 ## 348 1 12 348 ## 349 1 12 349 ## 350 1 12 350 ## 351 1 12 351 ## 352 1 12 352 ## 353 1 12 353 ## 354 1 12 354 ## 355 1 12 355 ## 356 1 12 356 ## 357 1 12 357 ## 358 1 12 358 ## 359 1 12 359 ## 360 1 12 360 ## 361 2 13 361 ## 362 2 13 362 ## 363 2 13 363 ## 364 2 13 364 ## 365 2 13 365 ## 366 2 13 366 ## 367 2 13 367 ## 368 2 13 368 ## 369 2 13 369 ## 370 2 13 370 ## 371 2 13 371 ## 372 2 13 372 ## 373 2 13 373 ## 374 2 13 374 ## 375 2 13 375 ## 376 2 13 376 ## 377 2 13 377 ## 378 2 13 378 ## 379 2 13 379 ## 380 2 13 380 ## 381 2 13 381 ## 382 2 13 382 ## 383 2 13 383 ## 384 2 13 384 ## 385 2 13 385 ## 386 2 13 386 ## 387 2 13 387 ## 388 2 13 388 ## 389 2 13 389 ## 390 2 13 390 ## 391 2 14 391 ## 392 2 14 392 ## 393 2 14 393 ## 394 2 14 394 ## 395 2 14 395 ## 396 2 14 396 ## 397 2 14 397 ## 398 2 14 398 ## 399 2 14 399 ## 400 2 14 400 ## 401 2 14 401 ## 402 2 14 402 ## 403 2 14 403 ## 404 2 14 404 ## 405 2 14 405 ## 406 2 14 406 ## 407 2 14 407 ## 408 2 14 408 ## 409 2 14 409 ## 410 2 14 410 ## 411 2 14 411 ## 412 2 14 412 ## 413 2 14 413 ## 414 2 14 414 ## 415 2 14 415 ## 416 2 14 416 ## 417 2 14 417 ## 418 2 14 418 ## 419 2 14 419 ## 420 2 14 420 ## 421 2 15 421 ## 422 2 15 422 ## 423 2 15 423 ## 424 2 15 424 ## 425 2 15 425 ## 426 2 15 426 ## 427 2 15 427 ## 428 2 15 428 ## 429 2 15 429 ## 430 2 15 430 ## 431 2 15 431 ## 432 2 15 432 ## 433 2 15 433 ## 434 2 15 434 ## 435 2 15 435 ## 436 2 15 436 ## 437 2 15 437 ## 438 2 15 438 ## 439 2 15 439 ## 440 2 15 440 ## 441 2 15 441 ## 442 2 15 442 ## 443 2 15 443 ## 444 2 15 444 ## 445 2 15 445 ## 446 2 15 446 ## 447 2 15 447 ## 448 2 15 448 ## 449 2 15 449 ## 450 2 15 450 ## 451 2 16 451 ## 452 2 16 452 ## 453 2 16 453 ## 454 2 16 454 ## 455 2 16 455 ## 456 2 16 456 ## 457 2 16 457 ## 458 2 16 458 ## 459 2 16 459 ## 460 2 16 460 ## 461 2 16 461 ## 462 2 16 462 ## 463 2 16 463 ## 464 2 16 464 ## 465 2 16 465 ## 466 2 16 466 ## 467 2 16 467 ## 468 2 16 468 ## 469 2 16 469 ## 470 2 16 470 ## 471 2 16 471 ## 472 2 16 472 ## 473 2 16 473 ## 474 2 16 474 ## 475 2 16 475 ## 476 2 16 476 ## 477 2 16 477 ## 478 2 16 478 ## 479 2 16 479 ## 480 2 16 480 ## 481 2 17 481 ## 482 2 17 482 ## 483 2 17 483 ## 484 2 17 484 ## 485 2 17 485 ## 486 2 17 486 ## 487 2 17 487 ## 488 2 17 488 ## 489 2 17 489 ## 490 2 17 490 ## 491 2 17 491 ## 492 2 17 492 ## 493 2 17 493 ## 494 2 17 494 ## 495 2 17 495 ## 496 2 17 496 ## 497 2 17 497 ## 498 2 17 498 ## 499 2 17 499 ## 500 2 17 500 ## 501 2 17 501 ## 502 2 17 502 ## 503 2 17 503 ## 504 2 17 504 ## 505 2 17 505 ## 506 2 17 506 ## 507 2 17 507 ## 508 2 17 508 ## 509 2 17 509 ## 510 2 17 510 ## 511 2 18 511 ## 512 2 18 512 ## 513 2 18 513 ## 514 2 18 514 ## 515 2 18 515 ## 516 2 18 516 ## 517 2 18 517 ## 518 2 18 518 ## 519 2 18 519 ## 520 2 18 520 ## 521 2 18 521 ## 522 2 18 522 ## 523 2 18 523 ## 524 2 18 524 ## 525 2 18 525 ## 526 2 18 526 ## 527 2 18 527 ## 528 2 18 528 ## 529 2 18 529 ## 530 2 18 530 ## 531 2 18 531 ## 532 2 18 532 ## 533 2 18 533 ## 534 2 18 534 ## 535 2 18 535 ## 536 2 18 536 ## 537 2 18 537 ## 538 2 18 538 ## 539 2 18 539 ## 540 2 18 540 ## 541 2 19 541 ## 542 2 19 542 ## 543 2 19 543 ## 544 2 19 544 ## 545 2 19 545 ## 546 2 19 546 ## 547 2 19 547 ## 548 2 19 548 ## 549 2 19 549 ## 550 2 19 550 ## 551 2 19 551 ## 552 2 19 552 ## 553 2 19 553 ## 554 2 19 554 ## 555 2 19 555 ## 556 2 19 556 ## 557 2 19 557 ## 558 2 19 558 ## 559 2 19 559 ## 560 2 19 560 ## 561 2 19 561 ## 562 2 19 562 ## 563 2 19 563 ## 564 2 19 564 ## 565 2 19 565 ## 566 2 19 566 ## 567 2 19 567 ## 568 2 19 568 ## 569 2 19 569 ## 570 2 19 570 ## 571 2 20 571 ## 572 2 20 572 ## 573 2 20 573 ## 574 2 20 574 ## 575 2 20 575 ## 576 2 20 576 ## 577 2 20 577 ## 578 2 20 578 ## 579 2 20 579 ## 580 2 20 580 ## 581 2 20 581 ## 582 2 20 582 ## 583 2 20 583 ## 584 2 20 584 ## 585 2 20 585 ## 586 2 20 586 ## 587 2 20 587 ## 588 2 20 588 ## 589 2 20 589 ## 590 2 20 590 ## 591 2 20 591 ## 592 2 20 592 ## 593 2 20 593 ## 594 2 20 594 ## 595 2 20 595 ## 596 2 20 596 ## 597 2 20 597 ## 598 2 20 598 ## 599 2 20 599 ## 600 2 20 600 ## 601 2 21 601 ## 602 2 21 602 ## 603 2 21 603 ## 604 2 21 604 ## 605 2 21 605 ## 606 2 21 606 ## 607 2 21 607 ## 608 2 21 608 ## 609 2 21 609 ## 610 2 21 610 ## 611 2 21 611 ## 612 2 21 612 ## 613 2 21 613 ## 614 2 21 614 ## 615 2 21 615 ## 616 2 21 616 ## 617 2 21 617 ## 618 2 21 618 ## 619 2 21 619 ## 620 2 21 620 ## 621 2 21 621 ## 622 2 21 622 ## 623 2 21 623 ## 624 2 21 624 ## 625 2 21 625 ## 626 2 21 626 ## 627 2 21 627 ## 628 2 21 628 ## 629 2 21 629 ## 630 2 21 630 ## 631 2 22 631 ## 632 2 22 632 ## 633 2 22 633 ## 634 2 22 634 ## 635 2 22 635 ## 636 2 22 636 ## 637 2 22 637 ## 638 2 22 638 ## 639 2 22 639 ## 640 2 22 640 ## 641 2 22 641 ## 642 2 22 642 ## 643 2 22 643 ## 644 2 22 644 ## 645 2 22 645 ## 646 2 22 646 ## 647 2 22 647 ## 648 2 22 648 ## 649 2 22 649 ## 650 2 22 650 ## 651 2 22 651 ## 652 2 22 652 ## 653 2 22 653 ## 654 2 22 654 ## 655 2 22 655 ## 656 2 22 656 ## 657 2 22 657 ## 658 2 22 658 ## 659 2 22 659 ## 660 2 22 660 ## 661 2 23 661 ## 662 2 23 662 ## 663 2 23 663 ## 664 2 23 664 ## 665 2 23 665 ## 666 2 23 666 ## 667 2 23 667 ## 668 2 23 668 ## 669 2 23 669 ## 670 2 23 670 ## 671 2 23 671 ## 672 2 23 672 ## 673 2 23 673 ## 674 2 23 674 ## 675 2 23 675 ## 676 2 23 676 ## 677 2 23 677 ## 678 2 23 678 ## 679 2 23 679 ## 680 2 23 680 ## 681 2 23 681 ## 682 2 23 682 ## 683 2 23 683 ## 684 2 23 684 ## 685 2 23 685 ## 686 2 23 686 ## 687 2 23 687 ## 688 2 23 688 ## 689 2 23 689 ## 690 2 23 690 ## 691 2 24 691 ## 692 2 24 692 ## 693 2 24 693 ## 694 2 24 694 ## 695 2 24 695 ## 696 2 24 696 ## 697 2 24 697 ## 698 2 24 698 ## 699 2 24 699 ## 700 2 24 700 ## 701 2 24 701 ## 702 2 24 702 ## 703 2 24 703 ## 704 2 24 704 ## 705 2 24 705 ## 706 2 24 706 ## 707 2 24 707 ## 708 2 24 708 ## 709 2 24 709 ## 710 2 24 710 ## 711 2 24 711 ## 712 2 24 712 ## 713 2 24 713 ## 714 2 24 714 ## 715 2 24 715 ## 716 2 24 716 ## 717 2 24 717 ## 718 2 24 718 ## 719 2 24 719 ## 720 2 24 720 make_structure(structure=&quot;year(2) + month(12) + day(30) + year:month:day&quot;, repeat_obs=1) ## year month day year:month:day ## 1 1 1 1 1 ## 2 1 1 2 2 ## 3 1 1 3 3 ## 4 1 1 4 4 ## 5 1 1 5 5 ## 6 1 1 6 6 ## 7 1 1 7 7 ## 8 1 1 8 8 ## 9 1 1 9 9 ## 10 1 1 10 10 ## 11 1 1 11 11 ## 12 1 1 12 12 ## 13 1 1 13 13 ## 14 1 1 14 14 ## 15 1 1 15 15 ## 16 1 1 16 16 ## 17 1 1 17 17 ## 18 1 1 18 18 ## 19 1 1 19 19 ## 20 1 1 20 20 ## 21 1 1 21 21 ## 22 1 1 22 22 ## 23 1 1 23 23 ## 24 1 1 24 24 ## 25 1 1 25 25 ## 26 1 1 26 26 ## 27 1 1 27 27 ## 28 1 1 28 28 ## 29 1 1 29 29 ## 30 1 1 30 30 ## 31 1 2 1 31 ## 32 1 2 2 32 ## 33 1 2 3 33 ## 34 1 2 4 34 ## 35 1 2 5 35 ## 36 1 2 6 36 ## 37 1 2 7 37 ## 38 1 2 8 38 ## 39 1 2 9 39 ## 40 1 2 10 40 ## 41 1 2 11 41 ## 42 1 2 12 42 ## 43 1 2 13 43 ## 44 1 2 14 44 ## 45 1 2 15 45 ## 46 1 2 16 46 ## 47 1 2 17 47 ## 48 1 2 18 48 ## 49 1 2 19 49 ## 50 1 2 20 50 ## 51 1 2 21 51 ## 52 1 2 22 52 ## 53 1 2 23 53 ## 54 1 2 24 54 ## 55 1 2 25 55 ## 56 1 2 26 56 ## 57 1 2 27 57 ## 58 1 2 28 58 ## 59 1 2 29 59 ## 60 1 2 30 60 ## 61 1 3 1 61 ## 62 1 3 2 62 ## 63 1 3 3 63 ## 64 1 3 4 64 ## 65 1 3 5 65 ## 66 1 3 6 66 ## 67 1 3 7 67 ## 68 1 3 8 68 ## 69 1 3 9 69 ## 70 1 3 10 70 ## 71 1 3 11 71 ## 72 1 3 12 72 ## 73 1 3 13 73 ## 74 1 3 14 74 ## 75 1 3 15 75 ## 76 1 3 16 76 ## 77 1 3 17 77 ## 78 1 3 18 78 ## 79 1 3 19 79 ## 80 1 3 20 80 ## 81 1 3 21 81 ## 82 1 3 22 82 ## 83 1 3 23 83 ## 84 1 3 24 84 ## 85 1 3 25 85 ## 86 1 3 26 86 ## 87 1 3 27 87 ## 88 1 3 28 88 ## 89 1 3 29 89 ## 90 1 3 30 90 ## 91 1 4 1 91 ## 92 1 4 2 92 ## 93 1 4 3 93 ## 94 1 4 4 94 ## 95 1 4 5 95 ## 96 1 4 6 96 ## 97 1 4 7 97 ## 98 1 4 8 98 ## 99 1 4 9 99 ## 100 1 4 10 100 ## 101 1 4 11 101 ## 102 1 4 12 102 ## 103 1 4 13 103 ## 104 1 4 14 104 ## 105 1 4 15 105 ## 106 1 4 16 106 ## 107 1 4 17 107 ## 108 1 4 18 108 ## 109 1 4 19 109 ## 110 1 4 20 110 ## 111 1 4 21 111 ## 112 1 4 22 112 ## 113 1 4 23 113 ## 114 1 4 24 114 ## 115 1 4 25 115 ## 116 1 4 26 116 ## 117 1 4 27 117 ## 118 1 4 28 118 ## 119 1 4 29 119 ## 120 1 4 30 120 ## 121 1 5 1 121 ## 122 1 5 2 122 ## 123 1 5 3 123 ## 124 1 5 4 124 ## 125 1 5 5 125 ## 126 1 5 6 126 ## 127 1 5 7 127 ## 128 1 5 8 128 ## 129 1 5 9 129 ## 130 1 5 10 130 ## 131 1 5 11 131 ## 132 1 5 12 132 ## 133 1 5 13 133 ## 134 1 5 14 134 ## 135 1 5 15 135 ## 136 1 5 16 136 ## 137 1 5 17 137 ## 138 1 5 18 138 ## 139 1 5 19 139 ## 140 1 5 20 140 ## 141 1 5 21 141 ## 142 1 5 22 142 ## 143 1 5 23 143 ## 144 1 5 24 144 ## 145 1 5 25 145 ## 146 1 5 26 146 ## 147 1 5 27 147 ## 148 1 5 28 148 ## 149 1 5 29 149 ## 150 1 5 30 150 ## 151 1 6 1 151 ## 152 1 6 2 152 ## 153 1 6 3 153 ## 154 1 6 4 154 ## 155 1 6 5 155 ## 156 1 6 6 156 ## 157 1 6 7 157 ## 158 1 6 8 158 ## 159 1 6 9 159 ## 160 1 6 10 160 ## 161 1 6 11 161 ## 162 1 6 12 162 ## 163 1 6 13 163 ## 164 1 6 14 164 ## 165 1 6 15 165 ## 166 1 6 16 166 ## 167 1 6 17 167 ## 168 1 6 18 168 ## 169 1 6 19 169 ## 170 1 6 20 170 ## 171 1 6 21 171 ## 172 1 6 22 172 ## 173 1 6 23 173 ## 174 1 6 24 174 ## 175 1 6 25 175 ## 176 1 6 26 176 ## 177 1 6 27 177 ## 178 1 6 28 178 ## 179 1 6 29 179 ## 180 1 6 30 180 ## 181 1 7 1 181 ## 182 1 7 2 182 ## 183 1 7 3 183 ## 184 1 7 4 184 ## 185 1 7 5 185 ## 186 1 7 6 186 ## 187 1 7 7 187 ## 188 1 7 8 188 ## 189 1 7 9 189 ## 190 1 7 10 190 ## 191 1 7 11 191 ## 192 1 7 12 192 ## 193 1 7 13 193 ## 194 1 7 14 194 ## 195 1 7 15 195 ## 196 1 7 16 196 ## 197 1 7 17 197 ## 198 1 7 18 198 ## 199 1 7 19 199 ## 200 1 7 20 200 ## 201 1 7 21 201 ## 202 1 7 22 202 ## 203 1 7 23 203 ## 204 1 7 24 204 ## 205 1 7 25 205 ## 206 1 7 26 206 ## 207 1 7 27 207 ## 208 1 7 28 208 ## 209 1 7 29 209 ## 210 1 7 30 210 ## 211 1 8 1 211 ## 212 1 8 2 212 ## 213 1 8 3 213 ## 214 1 8 4 214 ## 215 1 8 5 215 ## 216 1 8 6 216 ## 217 1 8 7 217 ## 218 1 8 8 218 ## 219 1 8 9 219 ## 220 1 8 10 220 ## 221 1 8 11 221 ## 222 1 8 12 222 ## 223 1 8 13 223 ## 224 1 8 14 224 ## 225 1 8 15 225 ## 226 1 8 16 226 ## 227 1 8 17 227 ## 228 1 8 18 228 ## 229 1 8 19 229 ## 230 1 8 20 230 ## 231 1 8 21 231 ## 232 1 8 22 232 ## 233 1 8 23 233 ## 234 1 8 24 234 ## 235 1 8 25 235 ## 236 1 8 26 236 ## 237 1 8 27 237 ## 238 1 8 28 238 ## 239 1 8 29 239 ## 240 1 8 30 240 ## 241 1 9 1 241 ## 242 1 9 2 242 ## 243 1 9 3 243 ## 244 1 9 4 244 ## 245 1 9 5 245 ## 246 1 9 6 246 ## 247 1 9 7 247 ## 248 1 9 8 248 ## 249 1 9 9 249 ## 250 1 9 10 250 ## 251 1 9 11 251 ## 252 1 9 12 252 ## 253 1 9 13 253 ## 254 1 9 14 254 ## 255 1 9 15 255 ## 256 1 9 16 256 ## 257 1 9 17 257 ## 258 1 9 18 258 ## 259 1 9 19 259 ## 260 1 9 20 260 ## 261 1 9 21 261 ## 262 1 9 22 262 ## 263 1 9 23 263 ## 264 1 9 24 264 ## 265 1 9 25 265 ## 266 1 9 26 266 ## 267 1 9 27 267 ## 268 1 9 28 268 ## 269 1 9 29 269 ## 270 1 9 30 270 ## 271 1 10 1 271 ## 272 1 10 2 272 ## 273 1 10 3 273 ## 274 1 10 4 274 ## 275 1 10 5 275 ## 276 1 10 6 276 ## 277 1 10 7 277 ## 278 1 10 8 278 ## 279 1 10 9 279 ## 280 1 10 10 280 ## 281 1 10 11 281 ## 282 1 10 12 282 ## 283 1 10 13 283 ## 284 1 10 14 284 ## 285 1 10 15 285 ## 286 1 10 16 286 ## 287 1 10 17 287 ## 288 1 10 18 288 ## 289 1 10 19 289 ## 290 1 10 20 290 ## 291 1 10 21 291 ## 292 1 10 22 292 ## 293 1 10 23 293 ## 294 1 10 24 294 ## 295 1 10 25 295 ## 296 1 10 26 296 ## 297 1 10 27 297 ## 298 1 10 28 298 ## 299 1 10 29 299 ## 300 1 10 30 300 ## 301 1 11 1 301 ## 302 1 11 2 302 ## 303 1 11 3 303 ## 304 1 11 4 304 ## 305 1 11 5 305 ## 306 1 11 6 306 ## 307 1 11 7 307 ## 308 1 11 8 308 ## 309 1 11 9 309 ## 310 1 11 10 310 ## 311 1 11 11 311 ## 312 1 11 12 312 ## 313 1 11 13 313 ## 314 1 11 14 314 ## 315 1 11 15 315 ## 316 1 11 16 316 ## 317 1 11 17 317 ## 318 1 11 18 318 ## 319 1 11 19 319 ## 320 1 11 20 320 ## 321 1 11 21 321 ## 322 1 11 22 322 ## 323 1 11 23 323 ## 324 1 11 24 324 ## 325 1 11 25 325 ## 326 1 11 26 326 ## 327 1 11 27 327 ## 328 1 11 28 328 ## 329 1 11 29 329 ## 330 1 11 30 330 ## 331 1 12 1 331 ## 332 1 12 2 332 ## 333 1 12 3 333 ## 334 1 12 4 334 ## 335 1 12 5 335 ## 336 1 12 6 336 ## 337 1 12 7 337 ## 338 1 12 8 338 ## 339 1 12 9 339 ## 340 1 12 10 340 ## 341 1 12 11 341 ## 342 1 12 12 342 ## 343 1 12 13 343 ## 344 1 12 14 344 ## 345 1 12 15 345 ## 346 1 12 16 346 ## 347 1 12 17 347 ## 348 1 12 18 348 ## 349 1 12 19 349 ## 350 1 12 20 350 ## 351 1 12 21 351 ## 352 1 12 22 352 ## 353 1 12 23 353 ## 354 1 12 24 354 ## 355 1 12 25 355 ## 356 1 12 26 356 ## 357 1 12 27 357 ## 358 1 12 28 358 ## 359 1 12 29 359 ## 360 1 12 30 360 ## 361 2 1 1 361 ## 362 2 1 2 362 ## 363 2 1 3 363 ## 364 2 1 4 364 ## 365 2 1 5 365 ## 366 2 1 6 366 ## 367 2 1 7 367 ## 368 2 1 8 368 ## 369 2 1 9 369 ## 370 2 1 10 370 ## 371 2 1 11 371 ## 372 2 1 12 372 ## 373 2 1 13 373 ## 374 2 1 14 374 ## 375 2 1 15 375 ## 376 2 1 16 376 ## 377 2 1 17 377 ## 378 2 1 18 378 ## 379 2 1 19 379 ## 380 2 1 20 380 ## 381 2 1 21 381 ## 382 2 1 22 382 ## 383 2 1 23 383 ## 384 2 1 24 384 ## 385 2 1 25 385 ## 386 2 1 26 386 ## 387 2 1 27 387 ## 388 2 1 28 388 ## 389 2 1 29 389 ## 390 2 1 30 390 ## 391 2 2 1 391 ## 392 2 2 2 392 ## 393 2 2 3 393 ## 394 2 2 4 394 ## 395 2 2 5 395 ## 396 2 2 6 396 ## 397 2 2 7 397 ## 398 2 2 8 398 ## 399 2 2 9 399 ## 400 2 2 10 400 ## 401 2 2 11 401 ## 402 2 2 12 402 ## 403 2 2 13 403 ## 404 2 2 14 404 ## 405 2 2 15 405 ## 406 2 2 16 406 ## 407 2 2 17 407 ## 408 2 2 18 408 ## 409 2 2 19 409 ## 410 2 2 20 410 ## 411 2 2 21 411 ## 412 2 2 22 412 ## 413 2 2 23 413 ## 414 2 2 24 414 ## 415 2 2 25 415 ## 416 2 2 26 416 ## 417 2 2 27 417 ## 418 2 2 28 418 ## 419 2 2 29 419 ## 420 2 2 30 420 ## 421 2 3 1 421 ## 422 2 3 2 422 ## 423 2 3 3 423 ## 424 2 3 4 424 ## 425 2 3 5 425 ## 426 2 3 6 426 ## 427 2 3 7 427 ## 428 2 3 8 428 ## 429 2 3 9 429 ## 430 2 3 10 430 ## 431 2 3 11 431 ## 432 2 3 12 432 ## 433 2 3 13 433 ## 434 2 3 14 434 ## 435 2 3 15 435 ## 436 2 3 16 436 ## 437 2 3 17 437 ## 438 2 3 18 438 ## 439 2 3 19 439 ## 440 2 3 20 440 ## 441 2 3 21 441 ## 442 2 3 22 442 ## 443 2 3 23 443 ## 444 2 3 24 444 ## 445 2 3 25 445 ## 446 2 3 26 446 ## 447 2 3 27 447 ## 448 2 3 28 448 ## 449 2 3 29 449 ## 450 2 3 30 450 ## 451 2 4 1 451 ## 452 2 4 2 452 ## 453 2 4 3 453 ## 454 2 4 4 454 ## 455 2 4 5 455 ## 456 2 4 6 456 ## 457 2 4 7 457 ## 458 2 4 8 458 ## 459 2 4 9 459 ## 460 2 4 10 460 ## 461 2 4 11 461 ## 462 2 4 12 462 ## 463 2 4 13 463 ## 464 2 4 14 464 ## 465 2 4 15 465 ## 466 2 4 16 466 ## 467 2 4 17 467 ## 468 2 4 18 468 ## 469 2 4 19 469 ## 470 2 4 20 470 ## 471 2 4 21 471 ## 472 2 4 22 472 ## 473 2 4 23 473 ## 474 2 4 24 474 ## 475 2 4 25 475 ## 476 2 4 26 476 ## 477 2 4 27 477 ## 478 2 4 28 478 ## 479 2 4 29 479 ## 480 2 4 30 480 ## 481 2 5 1 481 ## 482 2 5 2 482 ## 483 2 5 3 483 ## 484 2 5 4 484 ## 485 2 5 5 485 ## 486 2 5 6 486 ## 487 2 5 7 487 ## 488 2 5 8 488 ## 489 2 5 9 489 ## 490 2 5 10 490 ## 491 2 5 11 491 ## 492 2 5 12 492 ## 493 2 5 13 493 ## 494 2 5 14 494 ## 495 2 5 15 495 ## 496 2 5 16 496 ## 497 2 5 17 497 ## 498 2 5 18 498 ## 499 2 5 19 499 ## 500 2 5 20 500 ## 501 2 5 21 501 ## 502 2 5 22 502 ## 503 2 5 23 503 ## 504 2 5 24 504 ## 505 2 5 25 505 ## 506 2 5 26 506 ## 507 2 5 27 507 ## 508 2 5 28 508 ## 509 2 5 29 509 ## 510 2 5 30 510 ## 511 2 6 1 511 ## 512 2 6 2 512 ## 513 2 6 3 513 ## 514 2 6 4 514 ## 515 2 6 5 515 ## 516 2 6 6 516 ## 517 2 6 7 517 ## 518 2 6 8 518 ## 519 2 6 9 519 ## 520 2 6 10 520 ## 521 2 6 11 521 ## 522 2 6 12 522 ## 523 2 6 13 523 ## 524 2 6 14 524 ## 525 2 6 15 525 ## 526 2 6 16 526 ## 527 2 6 17 527 ## 528 2 6 18 528 ## 529 2 6 19 529 ## 530 2 6 20 530 ## 531 2 6 21 531 ## 532 2 6 22 532 ## 533 2 6 23 533 ## 534 2 6 24 534 ## 535 2 6 25 535 ## 536 2 6 26 536 ## 537 2 6 27 537 ## 538 2 6 28 538 ## 539 2 6 29 539 ## 540 2 6 30 540 ## 541 2 7 1 541 ## 542 2 7 2 542 ## 543 2 7 3 543 ## 544 2 7 4 544 ## 545 2 7 5 545 ## 546 2 7 6 546 ## 547 2 7 7 547 ## 548 2 7 8 548 ## 549 2 7 9 549 ## 550 2 7 10 550 ## 551 2 7 11 551 ## 552 2 7 12 552 ## 553 2 7 13 553 ## 554 2 7 14 554 ## 555 2 7 15 555 ## 556 2 7 16 556 ## 557 2 7 17 557 ## 558 2 7 18 558 ## 559 2 7 19 559 ## 560 2 7 20 560 ## 561 2 7 21 561 ## 562 2 7 22 562 ## 563 2 7 23 563 ## 564 2 7 24 564 ## 565 2 7 25 565 ## 566 2 7 26 566 ## 567 2 7 27 567 ## 568 2 7 28 568 ## 569 2 7 29 569 ## 570 2 7 30 570 ## 571 2 8 1 571 ## 572 2 8 2 572 ## 573 2 8 3 573 ## 574 2 8 4 574 ## 575 2 8 5 575 ## 576 2 8 6 576 ## 577 2 8 7 577 ## 578 2 8 8 578 ## 579 2 8 9 579 ## 580 2 8 10 580 ## 581 2 8 11 581 ## 582 2 8 12 582 ## 583 2 8 13 583 ## 584 2 8 14 584 ## 585 2 8 15 585 ## 586 2 8 16 586 ## 587 2 8 17 587 ## 588 2 8 18 588 ## 589 2 8 19 589 ## 590 2 8 20 590 ## 591 2 8 21 591 ## 592 2 8 22 592 ## 593 2 8 23 593 ## 594 2 8 24 594 ## 595 2 8 25 595 ## 596 2 8 26 596 ## 597 2 8 27 597 ## 598 2 8 28 598 ## 599 2 8 29 599 ## 600 2 8 30 600 ## 601 2 9 1 601 ## 602 2 9 2 602 ## 603 2 9 3 603 ## 604 2 9 4 604 ## 605 2 9 5 605 ## 606 2 9 6 606 ## 607 2 9 7 607 ## 608 2 9 8 608 ## 609 2 9 9 609 ## 610 2 9 10 610 ## 611 2 9 11 611 ## 612 2 9 12 612 ## 613 2 9 13 613 ## 614 2 9 14 614 ## 615 2 9 15 615 ## 616 2 9 16 616 ## 617 2 9 17 617 ## 618 2 9 18 618 ## 619 2 9 19 619 ## 620 2 9 20 620 ## 621 2 9 21 621 ## 622 2 9 22 622 ## 623 2 9 23 623 ## 624 2 9 24 624 ## 625 2 9 25 625 ## 626 2 9 26 626 ## 627 2 9 27 627 ## 628 2 9 28 628 ## 629 2 9 29 629 ## 630 2 9 30 630 ## 631 2 10 1 631 ## 632 2 10 2 632 ## 633 2 10 3 633 ## 634 2 10 4 634 ## 635 2 10 5 635 ## 636 2 10 6 636 ## 637 2 10 7 637 ## 638 2 10 8 638 ## 639 2 10 9 639 ## 640 2 10 10 640 ## 641 2 10 11 641 ## 642 2 10 12 642 ## 643 2 10 13 643 ## 644 2 10 14 644 ## 645 2 10 15 645 ## 646 2 10 16 646 ## 647 2 10 17 647 ## 648 2 10 18 648 ## 649 2 10 19 649 ## 650 2 10 20 650 ## 651 2 10 21 651 ## 652 2 10 22 652 ## 653 2 10 23 653 ## 654 2 10 24 654 ## 655 2 10 25 655 ## 656 2 10 26 656 ## 657 2 10 27 657 ## 658 2 10 28 658 ## 659 2 10 29 659 ## 660 2 10 30 660 ## 661 2 11 1 661 ## 662 2 11 2 662 ## 663 2 11 3 663 ## 664 2 11 4 664 ## 665 2 11 5 665 ## 666 2 11 6 666 ## 667 2 11 7 667 ## 668 2 11 8 668 ## 669 2 11 9 669 ## 670 2 11 10 670 ## 671 2 11 11 671 ## 672 2 11 12 672 ## 673 2 11 13 673 ## 674 2 11 14 674 ## 675 2 11 15 675 ## 676 2 11 16 676 ## 677 2 11 17 677 ## 678 2 11 18 678 ## 679 2 11 19 679 ## 680 2 11 20 680 ## 681 2 11 21 681 ## 682 2 11 22 682 ## 683 2 11 23 683 ## 684 2 11 24 684 ## 685 2 11 25 685 ## 686 2 11 26 686 ## 687 2 11 27 687 ## 688 2 11 28 688 ## 689 2 11 29 689 ## 690 2 11 30 690 ## 691 2 12 1 691 ## 692 2 12 2 692 ## 693 2 12 3 693 ## 694 2 12 4 694 ## 695 2 12 5 695 ## 696 2 12 6 696 ## 697 2 12 7 697 ## 698 2 12 8 698 ## 699 2 12 9 699 ## 700 2 12 10 700 ## 701 2 12 11 701 ## 702 2 12 12 702 ## 703 2 12 13 703 ## 704 2 12 14 704 ## 705 2 12 15 705 ## 706 2 12 16 706 ## 707 2 12 17 707 ## 708 2 12 18 708 ## 709 2 12 19 709 ## 710 2 12 20 710 ## 711 2 12 21 711 ## 712 2 12 22 712 ## 713 2 12 23 713 ## 714 2 12 24 714 ## 715 2 12 25 715 ## 716 2 12 26 716 ## 717 2 12 27 717 ## 718 2 12 28 718 ## 719 2 12 29 719 ## 720 2 12 30 720 "],["2.2-simulating-data-at-different-hierarchical-levels.html", "2.2 Simulating data at different hierarchical levels", " 2.2 Simulating data at different hierarchical levels We can simulate predictors at different hierarchical levels. Lets take the example of a situation where we have repeated measures of individuals. The individuals have traits that are consistently expressed, whilst the environment varies between observations. We can describe variation at these different hierarchical levels as: \\[ y = \\beta_0 + \\boldsymbol Z_j \\boldsymbol\\beta_z + \\boldsymbol X_i \\boldsymbol\\beta_x + \\epsilon_{i,j} \\] \\[ \\boldsymbol X \\sim MVN(\\mu_x,\\Sigma_x) \\] \\[ \\boldsymbol Z \\sim MVN(\\mu_z,\\Sigma_z) \\] \\[ \\epsilon \\sim N(0,\\sigma^2_\\epsilon) \\] where \\(Z\\) is a matrix of predictors at the individual level, and \\(X\\) is a matrix of predictors at the observation level. In order to simulate from this model, we need a data structure and parameters for each of these levels. To do this, we can either specify a data structure generated using make_structure (outlined in the previous section 2.1), or a pre-existing data structure, to the simulate_population function. We then add in a item to the parameter list, the name of which matches on of the grouping factors in the data structure, and specify the parameters for predictors that vary at that level in the same way as outlined in the previous section (1). squid_data &lt;- simulate_population( data_structure = make_structure(structure = &quot;individual(500)&quot;, repeat_obs=2), parameters = list( individual = list( names = c(&quot;size&quot;,&quot;behaviour&quot;,&quot;physiology&quot;), beta = c(0.1,0.3,0.2) ), observation = list( names=c(&quot;temperature&quot;,&quot;rainfall&quot;), beta = c(0.2,-0.1) ), residual = list( vcov = 0.5 ) ) ) data &lt;- get_population_data(squid_data) coef(lm(y ~ size + behaviour + physiology + temperature + rainfall , data)) ## (Intercept) size behaviour physiology temperature rainfall ## 0.02028965 0.08577533 0.26791917 0.21915674 0.21378102 -0.15268179 Here, we have simulated 5 predictors, ‘size’, ‘behaviour’ and ‘physiology’ that vary at the level of the individual, and ‘temperature’ and ‘rainfall’ that vary at the level of the observation (all with mean=0 and variance=1). Note, the names of the different grouping factors in the parameter list need to exactly match those in the data structure. The order does not, however, have to be the same. There are circumstances in which we may want to simulate two sets of effects at the same hierarchical level (for example see permanent environment effects in Section 4.1), in this case we can call them different things in the parameter list, but link them back to the grouping factor, by providing a group name. For example the following will produce the same simulation as above: squid_data &lt;- simulate_population( data_structure = make_structure(structure = &quot;individual(500)&quot;, repeat_obs=2), parameters = list( ind1 = list( group=&quot;individual&quot;, names = c(&quot;size&quot;), beta = c(0.1) ), ind2 = list( group=&quot;individual&quot;, names = c(&quot;behaviour&quot;,&quot;physiology&quot;), beta = c(0.3,0.2) ), observation = list( names=c(&quot;temperature&quot;,&quot;rainfall&quot;), beta = c(0.2,-0.1) ), residual = list( vcov = 0.5 ) ) ) It is also worth noting that predictors do not have to be simulated for every grouping factor in the data structure. 2.2.1 Simulating ‘random effects’ In essence, random effects (random intercepts) are an unobserved/latent predictor (or group of predictors), which varies at a given hierarchical level. In a mixed effect model, the effect at each level of the grouping factor is unknown, and estimated by the model (and assumed to come from a normal distribution). When simulating this, however, we can simply simulate an additional predictor at a particular level (\\(z\\)) with mean 0 and a given variance (\\(\\sigma^2_z\\)). \\[ y_{i,j} = \\beta_0 + z_j + \\epsilon_{i,j} \\] \\[ z \\sim N(0,\\sigma^2_z) \\] \\[ \\epsilon \\sim N(0,\\sigma^2_\\epsilon) \\] For example we can simulate some between-individual variation as follows: squid_data &lt;- simulate_population( data_structure = make_structure(structure = &quot;individual(500)&quot;, repeat_obs=2), parameters = list( individual = list( vcov = 0.5 ), residual = list( vcov = 0.5 ) ) ) data &lt;- get_population_data(squid_data) head(data) ## y individual_effect residual_effect individual squid_pop ## 1: 1.7368243 0.6923083 1.04451600 1 1 ## 2: 2.0409452 0.6923083 1.34863695 1 1 ## 3: 0.6765921 0.2468405 0.42975165 2 1 ## 4: 0.3372212 0.2468405 0.09038072 2 1 ## 5: 0.2533651 0.5369610 -0.28359595 3 1 ## 6: 0.5227875 0.5369610 -0.01417354 3 1 library(lme4) short_summary &lt;- function(x) print(summary(x), correlation=FALSE, show.resids=FALSE, ranef.comp = c(&quot;Variance&quot;)) short_summary(lmer(y ~ 1 + (1|individual), data)) ## Linear mixed model fit by REML [&#39;lmerMod&#39;] ## Formula: y ~ 1 + (1 | individual) ## Data: data ## ## REML criterion at convergence: 2668.9 ## ## Random effects: ## Groups Name Variance ## individual (Intercept) 0.5203 ## Residual 0.4691 ## Number of obs: 1000, groups: individual, 500 ## ## Fixed effects: ## Estimate Std. Error t value ## (Intercept) 0.02742 0.03885 0.706 Note that here we haven’t specified any variable names. In this case the simulated predictors are named by the grouping factors (e.g. individual_effects). 2.2.2 Incorporating existing data structures We could also use an existing data structure, taking the grouping factors and levels from an existing dataset and input them to simulate_population. To demonstrate this, we can use the blue tit dataset provided with the MCMCglmm package. This is a dataset with some continuous variables (tarsus, back (coloration) and hatchdate), and some grouping factors (animal, dam, fosternest and sex), the latter providing a data structure from which to simulate. library(MCMCglmm) data(BTdata) head(BTdata) ## tarsus back animal dam fosternest hatchdate sex ## 1 -1.89229718 1.1464212 R187142 R187557 F2102 -0.6874021 Fem ## 2 1.13610981 -0.7596521 R187154 R187559 F1902 -0.6874021 Male ## 3 0.98468946 0.1449373 R187341 R187568 A602 -0.4279814 Male ## 4 0.37900806 0.2555847 R046169 R187518 A1302 -1.4656641 Male ## 5 -0.07525299 -0.3006992 R046161 R187528 A2602 -1.4656641 Fem ## 6 -1.13519543 1.5577219 R187409 R187945 C2302 0.3502805 Fem squid_data &lt;- simulate_population( data_structure = BTdata[,c(&quot;dam&quot;,&quot;fosternest&quot;)], parameters = list( dam = list( vcov = 0.2 ), fosternest = list( vcov = 0.3 ), residual = list( vcov = 0.5 ) ) ) data &lt;- get_population_data(squid_data) data ## y dam_effect fosternest_effect residual_effect dam ## 1: -1.3522162 0.61419445 -1.1531118 -0.8132989 R187557 ## 2: 1.1901676 0.28622000 0.0305410 0.8734066 R187559 ## 3: 1.3526231 0.50335869 1.3972147 -0.5479503 R187568 ## 4: -0.4890261 0.09007932 0.3430862 -0.9221916 R187518 ## 5: 0.9020908 0.66692340 -0.3339971 0.5691645 R187528 ## --- ## 824: 0.6356330 0.93241806 -0.3260219 0.0292368 K983388 ## 825: 0.5344425 0.96867593 -0.1064933 -0.3277401 R186903 ## 826: 0.4255237 1.39479043 -0.3315679 -0.6376988 R187535 ## 827: 1.3774994 -0.18671218 0.4640102 1.1002014 R186911 ## 828: -0.6259804 -0.02416215 -0.9499108 0.3480925 R187001 ## fosternest squid_pop ## 1: F2102 1 ## 2: F1902 1 ## 3: A602 1 ## 4: A1302 1 ## 5: A2602 1 ## --- ## 824: H1102 1 ## 825: H702 1 ## 826: H502 1 ## 827: H302 1 ## 828: H102 1 "],["2.3-factors.html", "2.3 Factors", " 2.3 Factors So far the simulated predictors have all been continuous, but we may want to simulate factors with known or fixed effects i.e. not drawn from a normal distribution. In this case we can specify fixed = TRUE for a particular level, and then give a beta for all the different levels of that group. Lets take the example of sex. Factors can be thought of as a hierarcihc First we can create a data structure using the squid_data &lt;- simulate_population( data_structure = make_structure(structure = &quot;sex(2)/individual(500)&quot;, repeat_obs=2), parameters = list( sex=list( fixed=TRUE, names=c(&quot;female&quot;,&quot;male&quot;), beta=c(-0.5,0.5) ), residual = list( vcov = 0.5 ) ) ) data &lt;- get_population_data(squid_data) boxplot( y ~ factor(sex), data) lm( y ~ factor(sex), data) ## ## Call: ## lm(formula = y ~ factor(sex), data = data) ## ## Coefficients: ## (Intercept) factor(sex)2 ## -0.5019 1.0522 2.3.1 Fixed Factor Interactions squid_data &lt;- simulate_population( data_structure = make_structure(structure = &quot;sex(2)/individual(500)&quot;, repeat_obs=2), parameters = list( sex=list( fixed=TRUE, names=c(&quot;female&quot;,&quot;male&quot;), beta=c(-0.5,0.5) ), observation= list( names = c(&quot;environment&quot;), beta =c(0.2) ), interactions = list( names=c(&quot;environment:male&quot;), beta = 0.2 ), residual = list( names=&quot;residual&quot;, vcov = 0.1 ) ) ) data &lt;- get_population_data(squid_data) head(data) ## y female male environment environment:male residual sex ## 1: -0.9073455 1 0 -0.32301316 0 -0.3427428 1 ## 2: -0.1158326 1 0 0.22097396 0 0.3399726 1 ## 3: -0.5519508 1 0 0.34951799 0 -0.1218544 1 ## 4: -0.8567586 1 0 0.07708381 0 -0.3721754 1 ## 5: -0.3955215 1 0 1.23698885 0 -0.1429192 1 ## 6: -0.1614132 1 0 0.44649668 0 0.2492874 1 ## individual squid_pop ## 1: 1 1 ## 2: 1 1 ## 3: 2 1 ## 4: 2 1 ## 5: 3 1 ## 6: 3 1 plot(y~environment,data, pch=19, col=alpha(c(1,2),0.5)[factor(data$sex)]) lm( y ~ 0 + factor(sex)*environment, data) ## ## Call: ## lm(formula = y ~ 0 + factor(sex) * environment, data = data) ## ## Coefficients: ## factor(sex)1 factor(sex)2 environment ## -0.4945 0.5070 0.1995 ## factor(sex)2:environment ## 0.2062 "],["2.4-randomslopes.html", "2.4 Random slopes", " 2.4 Random slopes Random slopes are essentially an interaction between predictors at different levels, with the random slopes being an unobserved, latent variable. \\[ y_{i,j} = \\beta_0 + \\beta_1 x_{i,j} + z_{1,j} + z_{2,j}x_{i,j} + \\epsilon_{i,j} \\] \\[ Z \\sim MVN(0,\\Sigma_{z}) \\] \\[ \\epsilon \\sim N(0,\\sigma^2_\\epsilon) \\] We can specify random slopes by simulating a slopes variable at the individual level (ind_slope - \\(z_{2,j}\\)). We can specify the mean environmental effect the slope of the environmental variable (\\(beta_1\\)). \\(z_{2,j}\\) then represents the deviations from the mean slope (this is typically how it is modelling in a linear mixed effect model). Importantly the beta parameter associated with ind_slope is specified as 0 (there is no ‘main effect’ of the slopes, just the interaction), and the beta parameter associated with interaction is 1. squid_data &lt;- simulate_population( data_structure=make_structure(&quot;individual(300)&quot;,repeat_obs=10), parameters = list( individual = list( names = c(&quot;ind_int&quot;,&quot;ind_slope&quot;), beta = c(1,0), vcov = matrix(c(1,0.3,0.3,0.5),ncol=2,nrow=2) ), observation= list( names = c(&quot;environment&quot;), beta = c(0.2) ), residual = list( vcov = c(0.5) ), interactions = list( names = c(&quot;ind_slope:environment&quot;), beta = c(1) ) ) ) data &lt;- get_population_data(squid_data) short_summary(lmer(y ~ environment + (1+environment|individual),data)) ## Linear mixed model fit by REML [&#39;lmerMod&#39;] ## Formula: y ~ environment + (1 + environment | individual) ## Data: data ## ## REML criterion at convergence: 8020.5 ## ## Random effects: ## Groups Name Variance Corr ## individual (Intercept) 1.0641 ## environment 0.4587 0.39 ## Residual 0.5093 ## Number of obs: 3000, groups: individual, 300 ## ## Fixed effects: ## Estimate Std. Error t value ## (Intercept) 0.01747 0.06113 0.286 ## environment 0.22096 0.04191 5.272 "],["3-multivariate.html", "3 Multi-response Models", " 3 Multi-response Models We can simulate multiple response variables, that covary at different hierarchical levels. In the case of a simple random effects model, we can have a covariance matrix at each level, \\[ \\boldsymbol Y_{i,j} = \\boldsymbol\\beta_0 + \\boldsymbol Z_j + \\boldsymbol E_{i,j} \\] \\[ \\boldsymbol Z \\sim MVN(0,\\Sigma_z) \\] \\[ \\boldsymbol E \\sim MVN(0,\\Sigma_\\epsilon) \\] We can indicate that there are multiple phenotypes within the parameter list in two ways. First, we can use N_response in the parameter list, and specifying the covariance matrix (vcov) at each level. In this way we can simulate covariance at each level. squid_data &lt;- simulate_population( data_structure=make_structure(structure = &quot;individual(100)&quot;,repeat_obs=10), parameters=list( individual = list( vcov = matrix(c(1,0.5,0.5,1),nrow=2,ncol=2) ), residual = list( vcov = matrix(c(1,0.5,0.5,1),nrow = 2,ncol = 2) ) ), N_response = 2 ) data &lt;- get_population_data(squid_data) head(data) ## y1 y2 individual_effect1 individual_effect2 residual_effect1 ## 1: 2.1791078 3.377012 1.267444 1.915837 0.9116635 ## 2: 2.0308859 2.058498 1.267444 1.915837 0.7634416 ## 3: 2.6711522 2.066508 1.267444 1.915837 1.4037078 ## 4: 0.6388385 0.938600 1.267444 1.915837 -0.6286059 ## 5: 0.9180473 1.199943 1.267444 1.915837 -0.3493970 ## 6: 1.3829370 2.060139 1.267444 1.915837 0.1154927 ## residual_effect2 individual squid_pop ## 1: 1.4611747 1 1 ## 2: 0.1426602 1 1 ## 3: 0.1506706 1 1 ## 4: -0.9772374 1 1 ## 5: -0.7158946 1 1 ## 6: 0.1443016 1 1 –&gt; Second, we can build up predictors at each level that drive this covariance. Here we make beta into a matrix (\\(B\\)), with predictors as rows, and responses as columns. \\[ \\boldsymbol Y_{i,j} = \\beta_0 + \\boldsymbol Z_j B_z + \\boldsymbol X_i \\boldsymbol B_x + \\boldsymbol E_{i,j} \\] \\[ \\boldsymbol X \\sim MVN(\\mu_x,\\Sigma_x) \\] \\[ \\boldsymbol Z \\sim MVN(\\mu_z,\\Sigma_z) \\] \\[ \\boldsymbol E \\sim N(0,\\Sigma_\\epsilon) \\] The formulation above (just random effects), can be simulated in a similar way with beta as an identity matrix (i.e. a predictor for each trait). squid_data &lt;- simulate_population( data_structure= make_structure(structure = &quot;individual(100)&quot;,repeat_obs=10), parameters=list( individual = list( vcov =matrix(c(1,0.5,0.5,1),nrow=2,ncol=2), beta= diag(2) ), residual = list( vcov =matrix(c(1,0.5,0.5,1),nrow=2,ncol=2), beta= diag(2) ) ), N_response=2 ) data &lt;- get_population_data(squid_data) head(data) ## y1 y2 individual_effect1 individual_effect2 residual_effect1 ## 1: 0.5341391 0.82291608 1.235471 0.7442862 -0.7013316 ## 2: 2.3783510 0.85097436 1.235471 0.7442862 1.1428803 ## 3: 2.1234617 2.56468115 1.235471 0.7442862 0.8879910 ## 4: 1.6881490 0.38643589 1.235471 0.7442862 0.4526784 ## 5: 0.1187558 -0.09066676 1.235471 0.7442862 -1.1167149 ## 6: 0.6156444 -1.41794329 1.235471 0.7442862 -0.6198263 ## residual_effect2 individual squid_pop ## 1: 0.07862983 1 1 ## 2: 0.10668811 1 1 ## 3: 1.82039490 1 1 ## 4: -0.35785036 1 1 ## 5: -0.83495301 1 1 ## 6: -2.16222953 1 1 # library(MCMCglmm) # mod &lt;- MCMCglmm(cbind(y1,y2)~1,random=~us(trait):individual, rcov=~us(trait):units,data=data,family=rep(&quot;gaussian&quot;,2),verbose=FALSE) # summary(mod) Alternatively, you could also create multivariate phenotypes being affected by the same predictors. Here we have two phenotypes, affected by three predictors, and so we can create a 3x2 matrix of betas beta &lt;- matrix(c( 0.5, 0.1, 0.2, 0.2, 0.3, 0.1 ),nrow=3,ncol=2) beta ## [,1] [,2] ## [1,] 0.5 0.2 ## [2,] 0.1 0.3 ## [3,] 0.2 0.1 squid_data &lt;- simulate_population( data_structure= make_structure(structure = &quot;individual(100)&quot;,repeat_obs=20), parameters= list( individual = list( vcov =matrix(c(1,0.5,0.5,1),nrow=2,ncol=2) ), observation = list( names = c(&quot;temperature&quot;, &quot;rainfall&quot;, &quot;wind&quot;), beta= beta ), residual = list( vcov= matrix(c(1,0.5,0.5,1),nrow=2,ncol=2) ) ), N_response=2 ) data &lt;- get_population_data(squid_data) head(data) ## y1 y2 individual_effect1 individual_effect2 temperature ## 1: -1.1075131 -0.58785652 -0.5148209 0.3748109 -1.2679058 ## 2: 1.4928674 2.40005292 -0.5148209 0.3748109 0.4179419 ## 3: 0.2472825 0.03176847 -0.5148209 0.3748109 -0.6077977 ## 4: -1.2220839 0.17536373 -0.5148209 0.3748109 0.2005318 ## 5: -1.2255092 -1.10615980 -0.5148209 0.3748109 0.2609620 ## 6: 0.3043129 -0.31428382 -0.5148209 0.3748109 -1.6763525 ## rainfall wind residual_effect1 residual_effect2 individual squid_pop ## 1: -1.2486424 0.2162127 0.1228824 -0.3561148 1 1 ## 2: 1.2624090 -0.5532657 1.7831295 1.6182576 1 1 ## 3: 0.4284047 -0.8373845 1.1906387 -0.2662658 1 1 ## 4: -0.6543977 2.2506202 -1.1922132 -0.2682962 1 1 ## 5: -1.0862101 0.3189784 -0.7963440 -1.2391979 1 1 ## 6: -2.3502915 -1.1676843 2.1258760 0.4680317 1 1 # library(MCMCglmm) # mod &lt;- MCMCglmm(cbind(y1,y2)~1,random=~us(trait):individual, rcov=~us(trait):units,data=data,family=rep(&quot;gaussian&quot;,2),verbose=FALSE) # summary(mod) squid_data &lt;- simulate_population( data_structure= make_structure(structure = &quot;individual(100)&quot;,repeat_obs=20), parameters= list( individual = list( vcov =matrix(c(1,0.5,0.5,1),nrow=2,ncol=2) ), observation = list( names = c(&quot;temperature&quot;, &quot;rainfall&quot;, &quot;wind&quot;), beta= beta ), interactions = list( names = c(&quot;temperature:rainfall&quot;), beta=matrix(c(0.1,-0.3),ncol=2) ), residual = list( vcov= matrix(c(1,0.5,0.5,1),nrow=2,ncol=2) ) ), N_response=2 ) data &lt;- get_population_data(squid_data) head(data) ## y1 y2 individual_effect1 individual_effect2 temperature ## 1: 0.04367202 0.006774345 -0.6948651 -0.3747829 -0.3163814 ## 2: 0.06762783 -0.231354208 -0.6948651 -0.3747829 0.8060621 ## 3: 1.09215867 -0.656722790 -0.6948651 -0.3747829 1.4817262 ## 4: 1.05528269 -0.217181259 -0.6948651 -0.3747829 0.9137830 ## 5: -3.23933203 1.733407839 -0.6948651 -0.3747829 -2.3263583 ## 6: -0.97116152 -0.955296865 -0.6948651 -0.3747829 1.4511913 ## rainfall wind temperature:rainfall residual_effect1 ## 1: 0.2554959 -1.40578614 -0.08083416 1.1604189 ## 2: -0.4934689 -0.09297757 -0.39776663 0.4671809 ## 3: -1.4210176 0.08570312 -2.10555899 1.3816777 ## 4: 0.6487749 -0.87358662 0.59283942 1.3438122 ## 5: 1.3492588 0.69447545 -3.13885939 -1.3412228 ## 6: -1.5149440 0.61634150 -2.19847355 -0.7538186 ## residual_effect2 individual squid_pop ## 1: 0.48451308 1 1 ## 2: 0.02022469 1 1 ## 3: -0.79221791 1 1 ## 4: 0.04542304 1 1 ## 5: 1.15757936 1 1 ## 6: -1.13744528 1 1 # library(MCMCglmm) # mod &lt;- MCMCglmm(cbind(y1,y2)~1,random=~us(trait):individual, rcov=~us(trait):units,data=data,family=rep(&quot;gaussian&quot;,2),verbose=FALSE) # summary(mod) "],["3.1-one-response-repeatedly-measured-the-other-not.html", "3.1 One response repeatedly measured, the other not", " 3.1 One response repeatedly measured, the other not individual &lt;- list( vcov = matrix(c( 1,0.5, 0.5,1 ),nrow=2,ncol=2) ) residual &lt;- list( vcov = matrix(c( 1,0.5, 0.5,1 ),nrow = 2,ncol = 2), beta = matrix(c( 1,0, 0,0 ),nrow = 2,ncol = 2) ) squid_data &lt;- simulate_population( data_structure= make_structure(structure = &quot;individual(100)&quot;,repeat_obs=20), parameters=list(individual = individual, residual = residual), N_response = 2 ) data &lt;- get_population_data(squid_data) "],["3.2-different-distributions.html", "3.2 Different distributions", " 3.2 Different distributions individual &lt;- list( vcov = matrix(c( 1,0.5, 0.5,1 ),nrow=2,ncol=2) ) residual &lt;- list( vcov = matrix(c( 1,0.5, 0.5,1 ),nrow = 2,ncol = 2), beta = matrix(c( 1,0, 0,0 ),nrow = 2,ncol = 2) ) squid_data &lt;- simulate_population( data_structure= make_structure(structure = &quot;individual(100)&quot;,repeat_obs=20), parameters=list(individual = individual, residual = residual), N_response = 2, family=c(&quot;gaussian&quot;,&quot;binomial&quot;), link=c(&quot;identity&quot;,&quot;logit&quot;) ) data &lt;- get_population_data(squid_data) head(data,20) ## y1 y2 individual_effect1 individual_effect2 residual_effect1 ## 1: -0.58721929 1 1.247427 0.5312474 -1.83464616 ## 2: 1.17886161 1 1.247427 0.5312474 -0.06856526 ## 3: 0.41435604 0 1.247427 0.5312474 -0.83307083 ## 4: 2.40779159 1 1.247427 0.5312474 1.16036472 ## 5: 2.22466300 1 1.247427 0.5312474 0.97723613 ## 6: -0.08250208 1 1.247427 0.5312474 -1.32992895 ## 7: 0.34700858 0 1.247427 0.5312474 -0.90041829 ## 8: 2.05115547 1 1.247427 0.5312474 0.80372860 ## 9: -0.21255024 0 1.247427 0.5312474 -1.45997711 ## 10: 1.08646706 1 1.247427 0.5312474 -0.16095981 ## 11: 1.70506541 1 1.247427 0.5312474 0.45763855 ## 12: 0.36203942 1 1.247427 0.5312474 -0.88538745 ## 13: 3.24744845 0 1.247427 0.5312474 2.00002158 ## 14: 1.72966810 1 1.247427 0.5312474 0.48224124 ## 15: 2.29982959 0 1.247427 0.5312474 1.05240272 ## 16: -0.83303838 1 1.247427 0.5312474 -2.08046525 ## 17: 0.96135453 0 1.247427 0.5312474 -0.28607234 ## 18: -1.34022696 0 1.247427 0.5312474 -2.58765383 ## 19: 0.73817067 0 1.247427 0.5312474 -0.50925620 ## 20: 1.53768488 1 1.247427 0.5312474 0.29025801 ## residual_effect2 individual squid_pop ## 1: 0.1699124 1 1 ## 2: -1.1579362 1 1 ## 3: -0.1358165 1 1 ## 4: 1.0604907 1 1 ## 5: 1.6696873 1 1 ## 6: -0.5419707 1 1 ## 7: -0.5719374 1 1 ## 8: -0.4078652 1 1 ## 9: -1.3617572 1 1 ## 10: -2.0215548 1 1 ## 11: 0.3852501 1 1 ## 12: -0.5880273 1 1 ## 13: 1.9980537 1 1 ## 14: 2.0038769 1 1 ## 15: -0.2637844 1 1 ## 16: -0.8932288 1 1 ## 17: -1.2442459 1 1 ## 18: -3.4791464 1 1 ## 19: 1.2214492 1 1 ## 20: 1.3685696 1 1 data &lt;- get_population_data(squid_data) "],["3.3-multivariate-random-slopes.html", "3.3 Multivariate Random Slopes", " 3.3 Multivariate Random Slopes Before reading this it is worth checking out how to simulate univariate random slopes in Section 2.4. individual &lt;- list( names = c(&quot;ind_int1&quot;,&quot;ind_slope1&quot;,&quot;ind_int2&quot;,&quot;ind_slope2&quot;), vcov = matrix(c( 1, 0.5, 0, 0, 0.5, 1, 0, 0, 0, 0, 1, 0.2, 0, 0, 0.2, 1 ),nrow=4,ncol=4, byrow=TRUE), beta = matrix(c( 1, 0, 1, 0, 0, 1, 0, 1 ),nrow = 4,ncol = 2, byrow=TRUE) ) observation &lt;- list( names=&quot;environment&quot;, beta=matrix(c(0.5,-0.3), ncol=2) ) residual &lt;- list( vcov = matrix(c( 1,0.5, 0.5,1 ),nrow = 2,ncol = 2) ) interactions &lt;- list( names=c(&quot;ind_slope1:environment&quot;,&quot;ind_slope2:environment&quot;), beta= matrix(c( 1,0, 0,1 ), ncol=2) ) squid_data &lt;- simulate_population( data_structure = make_structure(structure = &quot;individual(100)&quot;,repeat_obs=20), N_response = 2, parameters=list( individual = individual, observation = observation, residual = residual, interactions = interactions ) ) data &lt;- get_population_data(squid_data) head(data,20) ## y1 y2 ind_int1 ind_slope1 ind_int2 ind_slope2 ## 1: 0.6010080 -3.8116789 -0.5372261 0.6373478 -1.129147 -0.4916217 ## 2: -1.3426115 -1.7041161 -0.5372261 0.6373478 -1.129147 -0.4916217 ## 3: -1.5990313 -1.7978570 -0.5372261 0.6373478 -1.129147 -0.4916217 ## 4: -2.3302272 -2.1072033 -0.5372261 0.6373478 -1.129147 -0.4916217 ## 5: -1.5777991 -2.2883737 -0.5372261 0.6373478 -1.129147 -0.4916217 ## 6: -2.2448745 -2.4434937 -0.5372261 0.6373478 -1.129147 -0.4916217 ## 7: 1.3812781 -2.2766079 -0.5372261 0.6373478 -1.129147 -0.4916217 ## 8: -0.3276678 -2.1421909 -0.5372261 0.6373478 -1.129147 -0.4916217 ## 9: -3.5070207 -3.4739887 -0.5372261 0.6373478 -1.129147 -0.4916217 ## 10: -0.8850525 -1.1076770 -0.5372261 0.6373478 -1.129147 -0.4916217 ## 11: -1.8040489 -1.9419917 -0.5372261 0.6373478 -1.129147 -0.4916217 ## 12: -0.7867494 -2.1216302 -0.5372261 0.6373478 -1.129147 -0.4916217 ## 13: 1.0845663 -3.4035539 -0.5372261 0.6373478 -1.129147 -0.4916217 ## 14: -0.7670172 -1.3567565 -0.5372261 0.6373478 -1.129147 -0.4916217 ## 15: 2.2341276 -1.2697359 -0.5372261 0.6373478 -1.129147 -0.4916217 ## 16: -2.6704615 0.3791242 -0.5372261 0.6373478 -1.129147 -0.4916217 ## 17: 2.5674158 -3.9489867 -0.5372261 0.6373478 -1.129147 -0.4916217 ## 18: -0.3152062 -1.7065206 -0.5372261 0.6373478 -1.129147 -0.4916217 ## 19: 0.1122822 -0.8183298 -0.5372261 0.6373478 -1.129147 -0.4916217 ## 20: 1.5086797 -0.5755677 -0.5372261 0.6373478 -1.129147 -0.4916217 ## environment residual_effect1 residual_effect2 ind_slope1:environment ## 1: 1.12451112 -0.77807394 -1.3007226 0.71670465 ## 2: -0.53273495 -0.83682824 -0.5050718 -0.33953743 ## 3: -0.34328503 -1.30871854 -0.4488400 -0.21879194 ## 4: -1.20219582 -1.06303416 -1.4381187 -0.76621682 ## 5: -0.54234042 -1.06109111 -1.0969332 -0.34565946 ## 6: -0.39672261 -1.89378463 -1.1367790 -0.25285027 ## 7: 0.43368614 0.78790446 -0.3125236 0.27640889 ## 8: -0.09707406 -0.31738251 -0.5982679 -0.06186994 ## 9: -0.89020529 -2.59466937 -2.5579256 -0.56737035 ## 10: -0.80062758 -0.07458220 -0.1207023 -0.51027820 ## 11: 0.05403474 -1.96562692 -0.2784477 0.03443892 ## 12: -0.26373625 -0.58691124 -0.7096406 -0.16809171 ## 13: 1.45498251 -0.67037649 -0.6309893 0.92732985 ## 14: -0.94538046 0.20808749 -0.4843713 -0.60253612 ## 15: 0.80003938 1.22408288 0.9843615 0.50990331 ## 16: -2.37428538 -0.07019508 0.1203573 -1.51324548 ## 17: 2.62583605 -0.51919466 -0.2495491 1.67357074 ## 18: -0.03073768 -0.38036849 -0.1100843 -0.01959059 ## 19: -0.23271679 0.27684041 0.6182155 -0.14832153 ## 20: 0.43568993 0.91302700 1.3901028 0.27768600 ## ind_slope2:environment individual squid_pop ## 1: -0.55283407 1 1 ## 2: 0.26190406 1 1 ## 3: 0.16876637 1 1 ## 4: 0.59102555 1 1 ## 5: 0.26662632 1 1 ## 6: 0.19503744 1 1 ## 7: -0.21320951 1 1 ## 8: 0.04772371 1 1 ## 9: 0.43764423 1 1 ## 10: 0.39360589 1 1 ## 11: -0.02656465 1 1 ## 12: 0.12965846 1 1 ## 13: -0.71530097 1 1 ## 14: 0.46476954 1 1 ## 15: -0.39331672 1 1 ## 16: 1.16725020 1 1 ## 17: -1.29091797 1 1 ## 18: 0.01511131 1 1 ## 19: 0.11440862 1 1 ## 20: -0.21419462 1 1 data &lt;- get_population_data(squid_data) "],["4-animal.html", "4 Genetic effects", " 4 Genetic effects This vignette assumes that you are generally happy with how the sim_population() function works. "],["4.1-va.html", "4.1 Additive genetics effects", " 4.1 Additive genetics effects In order to simulate breeding values (additive genetic effects), we can provide the simulate_population() function with the relatedness structure in the population. The simplest way to do this is providing a pedigree using the the pedigree argument (a genetic relatedness matrix could also be given to the cov_str argument). The input to this argument needs to be a list, and the name of the pedigree in the list links it with the item in the parameter list. When simulating breeding values, all individuals in pedigree need to be in the data_structure and vice versa. Having unsampled individuals (for example the base population) can be achieved in the sampling stage (not implemented yet). Lets start by importing a pedigree library(MCMCglmm) data(BTped) head(BTped) ## animal dam sire ## 1 R187557 &lt;NA&gt; &lt;NA&gt; ## 2 R187559 &lt;NA&gt; &lt;NA&gt; ## 3 R187568 &lt;NA&gt; &lt;NA&gt; ## 4 R187518 &lt;NA&gt; &lt;NA&gt; ## 5 R187528 &lt;NA&gt; &lt;NA&gt; ## 6 R187945 &lt;NA&gt; &lt;NA&gt; We can use this pedigree as a data_structure squid_data &lt;- simulate_population( data_structure = BTped, pedigree = list(animal=BTped), parameters =list( animal = list( vcov = 0.2 ), residual = list( vcov = 0.5 ) ) ) data &lt;- get_population_data(squid_data) head(data) ## y animal_effect residual_effect animal dam sire squid_pop ## 1: -0.65765199 0.01917794 -0.6768299 R187557 &lt;NA&gt; &lt;NA&gt; 1 ## 2: -0.02916514 0.11020280 -0.1393679 R187559 &lt;NA&gt; &lt;NA&gt; 1 ## 3: 0.73555249 0.13615972 0.5993928 R187568 &lt;NA&gt; &lt;NA&gt; 1 ## 4: 0.14372639 0.39430575 -0.2505794 R187518 &lt;NA&gt; &lt;NA&gt; 1 ## 5: -0.38166578 -0.04680802 -0.3348578 R187528 &lt;NA&gt; &lt;NA&gt; 1 ## 6: 0.55500173 0.15233047 0.4026713 R187945 &lt;NA&gt; &lt;NA&gt; 1 # Ainv&lt;-inverseA(BTped)$Ainv # mod &lt;- MCMCglmm(y~1, random=~ animal,data=data,ginverse=list(animal=Ainv),verbose=FALSE) # summary(mod) We might want to simulate repeated measurements to allow estimation of permanent environment effects. This is where being able to have something in the parameter list with a different name to the grouping factor is useful. In this way permanent environmental and additive genetic effects can be simulated in different parts of the parameter list, and linked to the same part of the data_structure. ## make data structure with two observations per individual ds &lt;- data.frame(individual=rep(BTped[,1], 2)) squid_data &lt;- simulate_population( data_structure = ds, pedigree=list(animal=BTped), parameters = list( individual = list( vcov = 0.3 ), animal = list( group=&quot;individual&quot;, vcov = 0.2 ), residual = list( vcov = 0.5 ) ) ) data &lt;- get_population_data(squid_data) head(data) ## y individual_effect animal_effect residual_effect individual ## 1: -1.19025061 -0.1703646 -0.2329027 -0.7869833 R187557 ## 2: 0.54661980 -0.5451609 0.7023840 0.3893967 R187559 ## 3: -1.64377053 -0.1527442 0.1496201 -1.6406464 R187568 ## 4: -0.44251476 -0.4784984 0.2411269 -0.2051433 R187518 ## 5: -0.56165586 0.2606702 -0.5633643 -0.2589617 R187528 ## 6: 0.02779786 -0.3408230 -0.2981108 0.6667316 R187945 ## squid_pop ## 1: 1 ## 2: 1 ## 3: 1 ## 4: 1 ## 5: 1 ## 6: 1 # Ainv&lt;-inverseA(BTped)$Ainv # data$animal_id &lt;- data$individual # mod &lt;- MCMCglmm(y~1, random=~ individual + animal_id,data=data,ginverse=list(animal_id=Ainv),verbose=FALSE) # summary(mod) "],["4.2-multivariate-genetic-effects.html", "4.2 Multivariate genetic effects", " 4.2 Multivariate genetic effects We can simulate genetic effects affecting multiple phenotypes and the covariance between them, by specifying the number of response variables, and a covariance matrix, instead of only a variance. squid_data &lt;- simulate_population( data_structure = BTped, pedigree = list(animal = BTped), parameters = list( animal = list( vcov = diag(2) ), residual = list( vcov = diag(2) ) ), N_response=2 ) data &lt;- get_population_data(squid_data) head(data) ## y1 y2 animal_effect1 animal_effect2 residual_effect1 ## 1: 1.1865233 -1.3624038 0.1978343 -1.0575881 0.9886890 ## 2: -0.6337098 -0.7496819 -0.8771544 -0.2782545 0.2434446 ## 3: -1.7225585 -0.1232221 -1.0073594 -0.8121222 -0.7151991 ## 4: -0.9160525 -0.9158656 0.5124476 0.2332408 -1.4285001 ## 5: 2.3824077 -0.9937048 1.4750506 -0.1260002 0.9073571 ## 6: 1.4276448 2.0279590 0.8942136 0.3476667 0.5334313 ## residual_effect2 animal dam sire squid_pop ## 1: -0.3048157 R187557 &lt;NA&gt; &lt;NA&gt; 1 ## 2: -0.4714274 R187559 &lt;NA&gt; &lt;NA&gt; 1 ## 3: 0.6889001 R187568 &lt;NA&gt; &lt;NA&gt; 1 ## 4: -1.1491064 R187518 &lt;NA&gt; &lt;NA&gt; 1 ## 5: -0.8677046 R187528 &lt;NA&gt; &lt;NA&gt; 1 ## 6: 1.6802923 R187945 &lt;NA&gt; &lt;NA&gt; 1 # Ainv&lt;-inverseA(BTped)$Ainv # mod &lt;- MCMCglmm(cbind(y1,y2)~1,random=~us(trait):animal, rcov=~us(trait):units,data=data,family=rep(&quot;gaussian&quot;,2),verbose=FALSE,ginverse=list(animal=Ainv)) # summary(mod) "],["4.3-sex-specific-genetic-variance-and-inter-sexual-genetic-correlations.html", "4.3 Sex specific genetic variance and inter-sexual genetic correlations", " 4.3 Sex specific genetic variance and inter-sexual genetic correlations ds &lt;- data.frame(animal=BTped[,&quot;animal&quot;],sex=sample(c(&quot;Female&quot;,&quot;Male&quot;),nrow(BTped), replace=TRUE)) squid_data &lt;- simulate_population( parameters = list( sex=list( fixed=TRUE, names=c(&quot;female&quot;,&quot;male&quot;), beta=c(-0.5,0.5) ), animal= list( names = c(&quot;G_female&quot;,&quot;G_male&quot;), vcov =matrix(c(0.1,-0.1,-0.1,0.4), nrow=2, ncol=2 ) ), residual = list( names=&quot;residual&quot;, vcov = 0.1 ) ), data_structure = ds, pedigree = list(animal=BTped), model = &quot;y = female + male + I(female)*G_female + I(male)*G_male + residual&quot; ) data &lt;- get_population_data(squid_data) head(data) ## y female male G_female G_male residual animal sex ## 1: -0.7955772 1 0 -0.06699576 0.49601288 -0.22858146 R187557 Female ## 2: 0.5625142 0 1 -0.14078017 0.12919379 -0.06667955 R187559 Male ## 3: -0.3502175 1 0 0.18088640 0.00510098 -0.03110392 R187568 Female ## 4: -1.0408476 1 0 -0.36070315 0.48268701 -0.18014448 R187518 Female ## 5: -0.7843466 1 0 0.07088876 -0.25053139 -0.35523539 R187528 Female ## 6: 0.8024596 0 1 -0.13921356 -0.05546940 0.35792896 R187945 Male ## squid_pop ## 1: 1 ## 2: 1 ## 3: 1 ## 4: 1 ## 5: 1 ## 6: 1 par(mfrow=c(1,2)) boxplot(y~factor(sex),data) plot(G_female~G_male,data) "],["4.4-gxe.html", "4.4 GxE", " 4.4 GxE squid_data &lt;- simulate_population( parameters = list( animal = list( names = c(&quot;G_int&quot;,&quot;G_slope&quot;), mean =c(0,0.2), vcov =matrix(c(1,0.3,0.3,0.5),ncol=2,nrow=2) ), observation= list( names = c(&quot;environment&quot;), vcov =c(1) ), residual = list( names = c(&quot;residual&quot;), vcov =c(0.5) ) ), data_structure=rbind(BTped,BTped,BTped,BTped,BTped), pedigree = list(animal=BTped), model=&quot;y = G_int + G_slope * environment + residual&quot; ) data &lt;- get_population_data(squid_data) library(lme4) short_summary &lt;- function(x) print(summary(x), correlation=FALSE, show.resids=FALSE, ranef.comp = c(&quot;Variance&quot;)) short_summary(lmer(y ~ environment + (1+environment|animal),data)) ## Linear mixed model fit by REML [&#39;lmerMod&#39;] ## Formula: y ~ environment + (1 + environment | animal) ## Data: data ## ## REML criterion at convergence: 15164.5 ## ## Random effects: ## Groups Name Variance Corr ## animal (Intercept) 1.0593 ## environment 0.5018 0.46 ## Residual 0.5129 ## Number of obs: 5200, groups: animal, 1040 ## ## Fixed effects: ## Estimate Std. Error t value ## (Intercept) -0.005896 0.033775 -0.175 ## environment 0.169770 0.025634 6.623 "],["4.5-indirect-genetic-effects.html", "4.5 Indirect Genetic Effects", " 4.5 Indirect Genetic Effects Indirect genetic effects are a bit more difficult to code.Lets take the example of maternal genetic effects. The maternal genetic effect that affects an individual’s phenotype, is that of its mother, not itself. Here we can use [] to index the levels of the random effects within the formula. This means that we can simulate the direct genetic and maternal genetic effects that an individual has (and the covariance between them), as well as generating an individual’s phenotype from its own direct genetic effects, and its mother’s maternal genetic effect. squid_data &lt;- simulate_population( parameters=list( animal = list( names=c(&quot;direct&quot;,&quot;maternal&quot;), vcov = matrix(c(1,0.3,0.3,0.5),2,2) ), residual = list( names=&quot;residual&quot;, vcov = 0.5 ) ), data_structure=BTped, pedigree=list(animal=BTped), model = &quot;y = direct + maternal[dam] + residual&quot; ) data &lt;- get_population_data(squid_data) head(data) ## y direct maternal residual animal dam sire squid_pop ## 1: NA -1.2891828 -0.79292290 -1.0482363 R187557 &lt;NA&gt; &lt;NA&gt; 1 ## 2: NA -0.1543170 0.07861385 -0.7026419 R187559 &lt;NA&gt; &lt;NA&gt; 1 ## 3: NA 0.7229234 -0.77422465 -0.2452710 R187568 &lt;NA&gt; &lt;NA&gt; 1 ## 4: NA 0.7866191 0.01021561 -0.8362501 R187518 &lt;NA&gt; &lt;NA&gt; 1 ## 5: NA 0.7239026 -0.06313994 0.4227411 R187528 &lt;NA&gt; &lt;NA&gt; 1 ## 6: NA 1.9337689 1.36868475 0.8580732 R187945 &lt;NA&gt; &lt;NA&gt; 1 "],["4.6-dominance.html", "4.6 Dominance", " 4.6 Dominance Here we can make use of the dominance relatedness matrices that can be generated in the nadiv package NOTE: not working fully yet!!! library(nadiv) D &lt;- makeD(BTped,invertD = FALSE, returnA = FALSE, det=FALSE)$D ## starting to make D....done ds &lt;- data.frame(animal=BTped[,&quot;animal&quot;],animal2=BTped[,&quot;animal&quot;]) squid_data &lt;- simulate_population( parameters=list( animal = list( vcov = 0.3 ), animal2 = list( vcov = 0.2 ), residual = list( vcov = 0.5 ) ), data_structure=ds, pedigree=list(animal=BTped), cov_str=list(animal2=D) ) data &lt;- get_population_data(squid_data) head(data) ## y animal_effect animal2_effect residual_effect animal animal2 ## 1: -1.0711373 0.22816578 -0.9160792 -0.38322390 R187557 R187557 ## 2: 1.3658062 0.49842666 0.7988667 0.06851286 R187559 R187559 ## 3: 2.0924484 1.01473651 0.7322774 0.34543452 R187568 R187568 ## 4: -0.9530023 0.03872477 -0.4724574 -0.51926971 R187518 R187518 ## 5: 0.7217865 0.18163360 0.1979889 0.34216395 R187528 R187528 ## 6: -0.6862967 0.19816394 0.5087701 -1.39323070 R187945 R187945 ## squid_pop ## 1: 1 ## 2: 1 ## 3: 1 ## 4: 1 ## 5: 1 ## 6: 1 "],["4.7-inbreeding-depression.html", "4.7 Inbreeding depression", " 4.7 Inbreeding depression Coming soon… "],["4.8-genetic-groups.html", "4.8 Genetic Groups", " 4.8 Genetic Groups Coming soon… "],["5-phylogenetic.html", "5 Phylogenetic Effects", " 5 Phylogenetic Effects Coming Soon :D "],["6-temporal-and-spatial-effects.html", "6 Temporal and Spatial Effects ", " 6 Temporal and Spatial Effects "],["6.1-simple-temporal-effects.html", "6.1 Simple Temporal Effects", " 6.1 Simple Temporal Effects We might have measured a variable over the course of a certain time period (e.g. 20 years). We might expect that there is stochastic year-to-year variation, which we can simulate already. However we might also want to simulate patterns in that temporal data. We can treat the levels associated with a particular grouping factor (e.g. year) as both a factor and continuous. To treat a grouping factor as continuous, we use covariate=TRUE in the parameter list. In this way we can simulate a linear effect of year: squid_data &lt;- simulate_population( data_structure= make_structure(structure = &quot;year(20) + sex(2)/individual(50)&quot;,repeat_obs=20), parameters=list( year_cont = list( group=&quot;year&quot;, names= &quot;year_cont&quot;, covariate=TRUE, beta=0.3 ), year = list( vcov = 0.8 ), residual=list( vcov = 1 ) ) ) note we have specified group in the parameter list. This enables us to link a set of parameters to the grouping factor in the data structure. This doesn’t have to be specified and defaults to the name of the list item. data &lt;- get_population_data(squid_data) head(data) ## y year_cont year_effect residual_effect year sex individual ## 1: 2.43351713 1 0.4616015 1.6719156 1 1 1 ## 2: 0.57507824 1 0.4616015 -0.1865233 1 1 1 ## 3: 1.79937627 1 0.4616015 1.0377747 1 1 1 ## 4: -0.38277566 1 0.4616015 -1.1443772 1 1 1 ## 5: -0.05573659 1 0.4616015 -0.8173381 1 1 1 ## 6: 1.56919218 1 0.4616015 0.8075906 1 1 1 ## squid_pop ## 1: 1 ## 2: 1 ## 3: 1 ## 4: 1 ## 5: 1 ## 6: 1 plot(y ~ year_cont, data) Here we can see there is within year variation, year to year variation, as well as a linear directional year effect. lmer(y ~ year_cont + (1|year), data) ## Linear mixed model fit by REML [&#39;lmerMod&#39;] ## Formula: y ~ year_cont + (1 | year) ## Data: data ## REML criterion at convergence: 113628.7 ## Random effects: ## Groups Name Std.Dev. ## year (Intercept) 0.6665 ## Residual 0.9997 ## Number of obs: 40000, groups: year, 20 ## Fixed Effects: ## (Intercept) year_cont ## -0.3682 0.3287 In a similar way we can also simulate a quadratic effect of time. squid_data &lt;- simulate_population( data_structure = make_structure(structure = &quot;year(20) + sex(2)/individual(50)&quot;,repeat_obs=20), parameters=list( year_cont = list( group=&quot;year&quot;, names= c(&quot;year_cont&quot;), covariate=TRUE, beta=c(0.3) ), interactions=list( names= c(&quot;year_cont:year_cont&quot;), beta=c(-0.05) ), year = list( vcov = 1 ), residual=list( vcov = 0.8 ) ) ) data &lt;- get_population_data(squid_data) plot(y~year_cont,data) "],["6.2-cyclical-temporal-effects.html", "6.2 Cyclical Temporal Effects", " 6.2 Cyclical Temporal Effects squidR uses the sinusoidal equation to implement cyclical temporal effects \\[ y = A sin(B(x - C)) + D \\] where A is the amplitude, \\(B/2\\pi\\) is the period \\(C/B\\) is the horizontal shift and D is the vertical shift. We can visualise this time &lt;- 1:20 amplitude &lt;- 10 # |A| = the amplitude period &lt;- 10 h_shift &lt;- 3 v_shift &lt;- 5 B &lt;- (2*pi) / abs(period) # 2pi/|B| = the period cyclic_effect &lt;- amplitude*sin(B*time - B^2*h_shift ) + v_shift plot(cyclic_effect~time) We can include this complexity into the model part of the simulate_population, adding the extra parameters for the cyclical effects into the year_cont part of the list. squid_data &lt;- simulate_population( parameters=list( year_cont = list( group=&quot;year&quot;, names= &quot;linear_effect&quot;, covariate=TRUE, beta=0.3, amplitude = 2, # |A| = the amplitude period = 10, h_shift = 3, v_shift = 5 ), year = list( vcov = 1.2 ), residual=list( vcov = 1 ) ), data_structure= make_structure(structure = &quot;year(20) + sex(2)/individual(50)&quot;,N=1000), model=&quot; B =(2*pi) / abs(period); cyclic_effect = amplitude*sin(B*I(linear_effect) - B^2*h_shift ) + v_shift; y = linear_effect + cyclic_effect + year_effect + residual_effect&quot; ) data &lt;- get_population_data(squid_data) plot(y~year,data) "],["6.3-temporalauto.html", "6.3 Temporal Autocorrelation", " 6.3 Temporal Autocorrelation "],["6.4-spatialauto.html", "6.4 Spatial Autocorrelation", " 6.4 Spatial Autocorrelation "],["7-sampling.html", "7 Sampling", " 7 Sampling To create different sampling schemes, we can use the sample arguments in the simulate_population() function, for example: sample_type = &quot;nested&quot;, sample_param = cbind(individual=c(10, 15),observation=c(10, 5)), There are three different types of sampling ‘nested’, ‘missing’ and ‘temporal’, each of which are outlined below. The sample arguments create different datasets for each population that has been simulated, and you can then use the function get_sample_data() to extract the sampled data. "],["7.1-nested.html", "7.1 Nested", " 7.1 Nested Nested sampling assumes that you have a nested structure, and allows you to sample different numbers at each hierarchical level. The param input is a matrix with (named) columns. The rows of this matrix represent different sampling sets. This is most easily put together using the cbind() (column bind) function, specifying the names. The number of repeat observations for a higher level can be specified using name ‘observation’ (this doesn’t have to exist in the data structure). For example cbind(individual=c(10, 15),observation=c(10, 5)) ## individual observation ## [1,] 10 10 ## [2,] 15 5 would represent sampling the data structure above, the first set having 10 individuals each with 10 observations Note this sampling procedure only produces balanced sampling designs. For unbalanced designs see ‘missing data’ below. 7.1.1 Worked example 1 We want to see how the number of repeat measurements on individuals affects power. In order to vary the number of observations of an individual, we could specify: param &lt;- cbind(nest=10,individual=10,observation=c(20, 10, 5, 2)) pop_data &lt;- simulate_population( data_structure = make_structure(&quot;nest(10)/individual(20)&quot;,repeat_obs=20), parameters = list( individual = list( vcov = 0.1 ), observation= list( names = c(&quot;environment&quot;), beta =c(0.5) ), residual = list( vcov = 0.8 ) ), sample_type = &quot;nested&quot;, sample_param = param ) To extract the sampled data we can then use get_sample_data() specifying which sample set we want, for example the second set 10 nests, each with 10 individuals with 10 observations: sample_data &lt;- get_sample_data(pop_data, sample_set=2) length(unique(sample_data$nest)) ## [1] 10 length(unique(sample_data$individual)) ## [1] 100 nrow(sample_data) ## [1] 1000 "],["7.2-missing-data.html", "7.2 Missing data", " 7.2 Missing data The missing data methods allows generation of unbalanced data. Missing data is generated through creating probabilities of being sampled using logistic regression. Missingness can then wither be random, or a function of any of the simulated variables. This methods allows the different classes of missing data to be generated: Missing Completely At Random (MCAR) All observations have an equal probability of being sampled Missing At Random (MAR) Probability of missingness is dependent a variables correlated with the response variable (i.e. a predictor variable) Missing Not At Random (MNAR) Probability of missingness is dependent on the response variable itself 7.2.1 MCAR Missing completely at random occurs when the probability of missingness is not dependent on anything. This can be implemented through a logistic regression, where only the intercept is specified: \\[ logit(p) = beta_0 \\] Note this intercept is on the logit scale, so 0 is equivalent to 0.5. pop_data &lt;- simulate_population( data_structure = make_structure(&quot;individual(100)&quot;,repeat_obs=5), parameters = list( individual = list( vcov = 0.1 ), observation= list( names = c(&quot;environment&quot;), beta =c(0.5) ), residual = list( vcov = 0.8 ) ), sample_type = &quot;missing&quot;, sample_param = &quot;0&quot; ) sample_data &lt;- get_sample_data(pop_data) nrow(sample_data) ## [1] 257 7.2.2 MAR Missing at random occurs when the probability of missingness is dependent on a predictor variable (or a variables correlated with y). This can be implemented through a logistic regression, where the predictor variable(s) is a predictor(s) of y: \\[ logit(p) = beta_0 + beta_1*environment \\] pop_data &lt;- simulate_population( data_structure = make_structure(&quot;individual(100)&quot;,repeat_obs=5), parameters = list( individual = list( vcov = 0.1 ), observation= list( names = c(&quot;environment&quot;), beta =c(0.5) ), residual = list( vcov = 0.8 ) ), sample_type = &quot;missing&quot;, sample_param = &quot;0.5*environment&quot; ) sample_data &lt;- get_sample_data(pop_data) nrow(sample_data) ## [1] 278 The predictor variables are scaled (mean 0, variance 1), so the slopes are directly comparable across traits, and intercept represents the mean (on the logit scale). 7.2.3 MNAR Missing not at random occurs when the probability of missingness is dependent on the response variable itself variable (i.e. y). This can be implemented through a logistic regression, where the predictor variable is y: \\[ logit(p) = beta_0 + beta_1*y \\] Again y is scaled. pop_data &lt;- simulate_population( data_structure = make_structure(&quot;individual(100)&quot;,repeat_obs=5), parameters = list( individual = list( vcov = 0.8 ), observation= list( names = c(&quot;environment&quot;), beta =c(0.1) ), residual = list( vcov = 0.5 ) ), sample_type = &quot;missing&quot;, sample_param = &quot;0.5*y&quot; ) sample_data &lt;- get_sample_data(pop_data) nrow(sample_data) ## [1] 242 Lets try and visualise this. We know there is lots f between individual variation, and we know sampling is based on phenotype, so we would expect an association between number of observations and phenotype: ind_data &lt;- data.frame( n=as.vector(table(sample_data$individual)), mean=tapply(sample_data$y,sample_data$individual,mean) ) boxplot(mean~n,ind_data) "],["7.3-temporal-sampling.html", "7.3 Temporal Sampling", " 7.3 Temporal Sampling In the parameters we specify a list, with the temporal variable time, the grouping variable with which the temporal sampling occurs group, the between group variance (as a proportion) in sampling times variance and the within group sample size N: pop_data &lt;- simulate_population( data_structure = make_structure(&quot;day(100) + individual(100)&quot;,repeat_obs=1), parameters = list( individual = list( vcov = 0.1 ), day=list( covariate=TRUE, beta=0.4 ), residual = list( vcov = 0.8 ) ), sample_type = &quot;temporal&quot;, sample_param = list( time = c(&quot;day&quot;), group = c(&quot;individual&quot;), variance = c(0.1,0.2), N=4), ) sample_data &lt;- get_sample_data(pop_data) "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
